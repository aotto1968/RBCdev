.\" Automatically generated by Pandoc 1.17.1
.\"
.ad l
.TH "vector" "n" "" "RBC(0.2)" "RBC Built-In Commands"
.hy
.SH NAME
.PP
vector \- Vector data type for Tcl
.SH SYNOPSIS
.PP
\f[B]vector create\f[] \f[I]vecName\f[] ?\f[I]vecName\f[]...?
?\f[I]switches\f[]?
.PP
\f[B]vector destroy\f[] \f[I]vecName\f[] ?\f[I]vecName\f[]...?
.PP
\f[B]vector expr\f[] \f[I]expression\f[]
.PP
\f[B]vector names\f[] ?\f[I]pattern\f[]...?
.SH DESCRIPTION
.PP
The \f[B]vector\f[] command creates a vector of floating point values.
The vector\[aq]s components can be manipulated in three ways: through a
Tcl array variable, a Tcl command, or the C API.
.SH INTRODUCTION
.PP
A vector is simply an ordered set of numbers.
The components of a vector are real numbers, indexed by counting
numbers.
.PP
Vectors are common data structures for many applications.
For example, a graph may use two vectors to represent the X\-Y
coordinates of the data plotted.
The graph will automatically be redrawn when the vectors are updated or
changed.
By using vectors, you can separate data analysis from the graph widget.
This makes it easier, for example, to add data transformations, such as
splines.
It\[aq]s possible to plot the same data to in multiple graphs, where
each graph presents a different view or scale of the data.
.PP
You could try to use Tcl\[aq]s associative arrays as vectors.
Tcl arrays are easy to use.
You can access individual elements randomly by specifying the index, or
the set the entire array by providing a list of index and value pairs
for each element.
The disadvantages of associative arrays as vectors lie in the fact they
are implemented as hash tables.
.IP \[bu] 2
There\[aq]s no implied ordering to the associative arrays.
If you used vectors for plotting, you would want to insure the second
component comes after the first, an so on.
This isn\[aq]t possible since arrays are actually hash tables.
For example, you can\[aq]t get a range of values between two indices.
Nor can you sort an array.
.IP \[bu] 2
Arrays consume lots of memory when the number of elements becomes large
(tens of thousands).
This is because each element\[aq]s index and value are stored as strings
in the hash table.
.IP \[bu] 2
The C programming interface is unwieldy.
Normally with vectors, you would like to view the Tcl array as you do a
C array, as an array of floats or doubles.
But with hash tables, you must convert both the index and value to and
from decimal strings, just to access an element in the array.
This makes it cumbersome to perform operations on the array as a whole.
.PP
The \f[B]vector\f[] command tries to overcome these disadvantages while
still retaining the ease of use of Tcl arrays.
The \f[B]vector\f[] command creates both a new Tcl command and associate
array which are linked to the vector components.
You can randomly access vector components though the elements of array.
Not have all indices are generated for the array, so printing the array
(using the \f[B]parray\f[] procedure) does not print out all the
component values.
You can use the Tcl command to access the array as a whole.
You can copy, append, or sort vector using its command.
If you need greater performance, or customized behavior, you can write
your own C code to manage vectors.
.SH EXAMPLE
.PP
You create vectors using the \f[B]vector\f[] command and its
\f[B]create\f[] operation.
.IP
.nf
\f[C]
#\ Create\ a\ new\ vector.
vector\ create\ y(50)
\f[]
.fi
.PP
This creates a new vector named y.
It has fifty components, by default, initialized to 0.0.
In addition, both a Tcl command and array variable, both named y, are
created.
You can use either the command or variable to query or modify components
of the vector.
.IP
.nf
\f[C]
#\ Set\ the\ first\ value.
set\ y(0)\ 9.25
puts\ "y\ has\ [y\ length]\ components"
\f[]
.fi
.PP
The array y can be used to read or set individual components of the
vector.
Vector components are indexed from zero.
The array index must be a number less than the number of components.
For example, it\[aq]s an error if you try to set the 51st element of y.
.IP
.nf
\f[C]
#\ This\ is\ an\ error.\ The\ vector\ only\ has\ 50\ components.
set\ y(50)\ 0.02
\f[]
.fi
.PP
You can also specify a range of indices using a colon (:) to separate
the first and last indices of the range.
.IP
.nf
\f[C]
#\ Set\ the\ first\ six\ components\ of\ y
set\ y(0:5)\ 25.2
\f[]
.fi
.PP
If you don\[aq]t include an index, then it will default to the first
and/or last component of the vector.
.IP
.nf
\f[C]
#\ Print\ out\ all\ the\ components\ of\ y
puts\ "y\ =\ $y(:)"
\f[]
.fi
.PP
There are special non\-numeric indices.
The index end, specifies the last component of the vector.
It\[aq]s an error to use this index if the vector is empty (length is
zero).
The index ++end can be used to extend the vector by one component and
initialize it to a specific value.
You can\[aq]t read from the array using this index, though.
.IP
.nf
\f[C]
#\ Extend\ the\ vector\ by\ one\ component.
set\ y(++end)\ 0.02
\f[]
.fi
.PP
The other special indices are min and max.
They return the current smallest and largest components of the vector.
.IP
.nf
\f[C]
#\ Print\ the\ bounds\ of\ the\ vector
puts\ "min=$y(min)\ max=$y(max)"
\f[]
.fi
.PP
To delete components from a vector, simply unset the corresponding array
element.
In the following example, the first component of y is deleted.
All the remaining components of y will be moved down by one index as the
length of the vector is reduced by one.
.IP
.nf
\f[C]
#\ Delete\ the\ first\ component
unset\ y(0)
puts\ "new\ first\ element\ is\ $y(0)"
\f[]
.fi
.PP
The vector\[aq]s Tcl command can also be used to query or set the
vector.
.IP
.nf
\f[C]
#\ Create\ and\ set\ the\ components\ of\ a\ new\ vector
vector\ create\ x
x\ set\ {\ 0.02\ 0.04\ 0.06\ 0.08\ 0.10\ 0.12\ 0.14\ 0.16\ 0.18\ 0.20\ }
\f[]
.fi
.PP
Here we\[aq]ve created a vector x without a initial length
specification.
In this case, the length is zero.
The \f[B]set\f[] operation resets the vector, extending it and setting
values for each new component.
.PP
There are several operations for vectors.
The \f[B]range\f[] operation lists the components of a vector between
two indices.
.IP
.nf
\f[C]
#\ List\ the\ components
puts\ "x\ =\ [x\ range\ 0\ end]"
\f[]
.fi
.PP
You can search for a particular value using the \f[B]search\f[]
operation.
It returns a list of indices of the components with the same value.
If no component has the same value, it returns "".
.IP
.nf
\f[C]
#\ Find\ the\ index\ of\ the\ biggest\ component
set\ indices\ [x\ search\ $x(max)]
\f[]
.fi
.PP
Other operations copy, append, or sort vectors.
You can append vectors or new values onto an existing vector with the
\f[B]append\f[] operation.
.IP
.nf
\f[C]
#\ Append\ assorted\ vectors\ and\ values\ to\ x
x\ append\ x2\ x3\ {\ 2.3\ 4.5\ }\ x4
\f[]
.fi
.PP
The \f[B]sort\f[] operation sorts the vector.
If any additional vectors are specified, they are rearranged in the same
order as the vector.
For example, you could use it to sort data points represented by x and y
vectors.
.IP
.nf
\f[C]
#\ Sort\ the\ data\ points
x\ sort\ y
\f[]
.fi
.PP
The vector x is sorted while the components of y are rearranged so that
the original x,y coordinate pairs are retained.
.PP
The \f[B]expr\f[] operation lets you perform arithmetic on vectors.
The result is stored in the vector.
.IP
.nf
\f[C]
#\ Add\ the\ two\ vectors\ and\ a\ scalar
x\ expr\ {\ x\ +\ y\ }
x\ expr\ {\ x\ *\ 2\ }
\f[]
.fi
.PP
When a vector is modified, resized, or deleted, it may trigger call\-
backs to notify the clients of the vector.
For example, when a vector used in the \f[B]graph\f[] widget is updated,
the vector automatically notifies the widget that it has changed.
The graph can then redrawn itself at the next idle point.
By default, the notification occurs when Tk is next idle.
This way you can modify the vector many times without incurring the
penalty of the graph redrawing itself for each change.
You can change this behavior using the \f[B]notify\f[] operation.
.IP
.nf
\f[C]
#\ Make\ vector\ x\ notify\ after\ every\ change
x\ notify\ always
\ \ ...
#\ Never\ notify
x\ notify\ never
\ \ ...
#\ Force\ notification\ now
x\ notify\ now
\f[]
.fi
.PP
To delete a vector, use the \f[B]vector delete\f[] command.
Both the vector and its corresponding Tcl command are destroyed.
.IP
.nf
\f[C]
#\ Remove\ vector\ x
vector\ destroy\ x
\f[]
.fi
.SH SYNTAX
.PP
Vectors are created using the \f[B]vector create\f[] operation.
Th \f[B]create\f[] operation can be invoked in one of three forms:
.TP
.B vector create \f[I]vecName\f[]
This creates a new vector \f[I]vecName\f[] which initially has no
components.
.RS
.RE
.TP
.B vector create \f[I]vecName\f[](\f[I]size\f[])
This second form creates a new vector which will contain \f[I]size\f[]
number of components.
The components will be indexed starting from zero (0).
The default value for the components is 0.0.
.RS
.RE
.TP
.B vector create \f[I]vecName\f[](\f[I]first\f[]:\f[I]last\f[])
The last form creates a new vector of indexed \f[I]first\f[] through
\f[I]last\f[].
\f[I]First\f[] and \f[I]last\f[] can be any integer value so long as
\f[I]first\f[] is less than \f[I]last\f[].
.RS
.RE
.PP
Vector names must start with a letter and consist of letters, digits, or
underscores.
.IP
.nf
\f[C]
#\ Error:\ must\ start\ with\ letter
vector\ create\ 1abc
\f[]
.fi
.PP
You can automatically generate vector names using the "#auto" vector
.TP
.B name.
The \f[B]create\f[] operation will generate a unique vector name.
.RS
.PP
set vec [vector create #auto]
.PD 0
.P
.PD
puts "$vec has [$vec length] components"
.RE
.SS VECTOR INDICES
.PP
Vectors are indexed by integers.
You can access the individual vector components via its array variable
or Tcl command.
The string representing the index can be an integer, a numeric
expression, a range, or a special keyword.
.PP
The index must lie within the current range of the vector, otherwise an
an error message is returned.
Normally the indices of a vector are start from 0.
But you can use the \f[B]offset\f[] operation to change a vector\[aq]s
indices on\-the\-fly.
.IP
.nf
\f[C]
puts\ $vecName(0)
vecName\ offset\ \-5
puts\ $vecName(\-5)
\f[]
.fi
.PP
You can also use numeric expressions as indices.
The result of the expression must be an integer value.
.IP
.nf
\f[C]
set\ n\ 21
set\ vecName($n+3)\ 50.2
\f[]
.fi
.PP
The following special non\-numeric indices are available: min, max, end,
and ++end.
.IP
.nf
\f[C]
puts\ "min\ =\ $vecName($min)"
set\ vecName(end)\ \-1.2
\f[]
.fi
.PP
The indices min and max will return the minimum and maximum values of
the vector.
The index end returns the value of the last component in the vector.
The index ++end is used to append new value onto the vector.
It automatically extends the vector by one component and sets its value.
.IP
.nf
\f[C]
#\ Append\ an\ new\ component\ to\ the\ end
set\ vecName(++end)\ 3.2
\f[]
.fi
.PP
A range of indices can be indicated by a colon (:).
.IP
.nf
\f[C]
#\ Set\ the\ first\ six\ components\ to\ 1.0
set\ vecName(0:5)\ 1.0
\f[]
.fi
.PP
If no index is supplied the first or last component is assumed.
.IP
.nf
\f[C]
#\ Print\ the\ values\ of\ all\ the\ components
puts\ $vecName(:)
\f[]
.fi
.SH VECTOR OPERATIONS
.TP
.B \f[B]vector create\f[] \f[I]vecName\f[]?(\f[I]size\f[])?... ?\f[I]switches\f[]?
The \f[B]create\f[] operation creates a new vector \f[I]vecName\f[].
Both a Tcl command and array variable \f[I]vecName\f[] are also created.
The name \f[I]vecName\f[] must be unique, so another Tcl command or
array variable can not already exist in that scope.
You can access the components of the vector using its variable.
If you change a value in the array, or unset an array element, the
vector is updated to reflect the changes.
When the variable \f[I]vecName\f[] is unset, the vector and its Tcl
command are also destroyed.
.RS
.PP
The vector has optional switches that affect how the vector is created.
They are as follows:
.TP
.B \-variable \f[I]varName\f[]
Specifies the name of a Tcl variable to be mapped to the vector.
If the variable already exists, it is first deleted, then recreated.
If \f[I]varName\f[] is the empty string, then no variable will be
mapped.
You can always map a variable back to the vector using the vector\[aq]s
\f[B]variable\f[] operation.
.RS
.RE
.TP
.B \-command \f[I]cmdName\f[]
Maps a Tcl command to the vector.
The vector can be accessed using \f[I]cmdName\f[] and one of the vector
instance operations.
A Tcl command by that name cannot already exist.
If \f[I]cmdName\f[] is the empty string, no command mapping will be
made.
.RS
.RE
.TP
.B \-watchunset \f[I]boolean\f[]
Indicates that the vector should automatically delete itself if the
variable associated with the vector is unset.
By default, the vector will not be deleted.
This is different from previous releases.
Set \f[I]boolean\f[] to "true" to get the old behavior.
.RS
.RE
.RE
.TP
.B \f[B]vector destroy\f[] \f[I]vecName\f[] ?\f[I]vecName...\f[]?
\&...
.RS
.RE
.TP
.B \f[B]vector expr\f[] \f[I]expression\f[]
All binary operators take vectors as operands (remember that numbers are
treated as one\-component vectors).
The exact action of binary operators depends upon the length of the
second operand.
If the second operand has only one component, then each element of the
first vector operand is computed by that value.
For example, the expression "x * 2" multiples all elements of the vector
x by 2.
If the second operand has more than one component, both operands must be
the same length.
Each pair of corresponding elements are computed.
So "x + y" adds the the first components of x and y together, the
second, and so on.
.RS
.PP
The valid operators are listed below, grouped in decreasing order of
precedence:
.TP
.B \- !
Unary minus and logical NOT.
The unary minus flips the sign of each component in the vector.
The logical not operator returns a vector of whose values are 0.0 or
1.0.
For each non\-zero component 1.0 is returned, 0.0 otherwise.
.RS
.RE
.TP
.B ^
Exponentiation.
.RS
.RE
.TP
.B * / %
Multiply, divide, remainder.
.RS
.RE
.TP
.B + \-
Add and subtract.
.RS
.RE
.TP
.B << >>
Left and right shift.
Circularly shifts the values of the vector (not implemented yet).
.RS
.RE
.TP
.B < > <= >=
Boolean less, greater, less than or equal, and greater than or equal.
Each operator returns a vector of ones and zeros.
If the condition is true, 1.0 is the component value, 0.0 otherwise.
.RS
.RE
.TP
.B == !=
Boolean equal and not equal.
Each operator returns a vector of ones and zeros.
If the condition is true, 1.0 is the component value, 0.0 otherwise.
.RS
.RE
.TP
.B |
Bit\-wise OR.
(Not implemented).
.RS
.RE
.TP
.B &&
Logical AND.
Produces a 1 result if both operands are non\-zero, 0 otherwise.
.RS
.RE
.TP
.B ||
Logical OR.
Produces a 0 result if both operands are zero, 1 otherwise.
.RS
.RE
.TP
.B \f[I]x\f[]?\f[I]y\f[]:\f[I]z\f[]
If\-then\-else, as in C.
(Not implemented yet).
.RS
.RE
.PP
See the C manual for more details on the results produced by each
operator.
All of the binary operators group left\-to\-right within the same
precedence level.
.PP
Several mathematical functions are supported for vectors.
Each of the following functions invokes the math library function of the
same name; see the manual entries for the library functions for details
on what they do.
The operation is applied to all elements of the vector returning the
results.
.TP
.B acos
\f[B]cos hypot sinh\f[]
.RS
.RE
.TP
.B asin
\f[B]cosh log sqrt\f[]
.RS
.RE
.TP
.B atan
\f[B]exp log10 tan\f[]
.RS
.RE
.TP
.B ceil
\f[B]floor sin tanh\f[]
.RS
.RE
.PP
Additional functions are:
.TP
.B abs
Returns the absolute value of each component.
.RS
.RE
.TP
.B random
Returns a vector of non\-negative values uniformly distributed between
[0.0, 1.0) using \f[I]drand48\f[].
The seed comes from the internal clock of the machine or may be set
manual with the srandom function.
.RS
.RE
.TP
.B round
Rounds each component of the vector.
.RS
.RE
.TP
.B srandom
Initializes the random number generator using \f[I]srand48\f[].
The high order 32\-bits are set using the integral portion of the first
vector component.
All other components are ignored.
The low order 16\-bits are set to an arbitrary value.
.RS
.RE
.PP
The following functions return a single value.
.TP
.B adev
Returns the average deviation (defined as the sum of the absolute values
of the differences between component and the mean, divided by the length
of the vector).
.RS
.RE
.TP
.B kurtosis
Returns the degree of peakedness (fourth moment) of the vector.
.RS
.RE
.TP
.B length
Returns the number of components in the vector.
.RS
.RE
.TP
.B max
Returns the vector\[aq]s maximum value.
.RS
.RE
.TP
.B mean
Returns the mean value of the vector.
.RS
.RE
.TP
.B median
Returns the median of the vector.
.RS
.RE
.TP
.B min
Returns the vector\[aq]s minimum value.
.RS
.RE
.TP
.B q1
Returns the first quartile of the vector.
.RS
.RE
.TP
.B q3
Returns the third quartile of the vector.
.RS
.RE
.TP
.B prod
Returns the product of the components.
.RS
.RE
.TP
.B sdev
Returns the standard deviation (defined as the square root of the
variance) of the vector.
.RS
.RE
.TP
.B skew
Returns the skewness (or third moment) of the vector.
This characterizes the degree of asymmetry of the vector about the mean.
.RS
.RE
.TP
.B sum
Returns the sum of the components.
.RS
.RE
.TP
.B var
Returns the variance of the vector.
The sum of the squared differences between each component and the mean
is computed.
The variance is the sum divided by the length of the vector minus 1.
.RS
.RE
.PP
The last set returns a vector of the same length as the argument.
.TP
.B norm
Scales the values of the vector to lie in the range [0.0..1.0].
.RS
.RE
.TP
.B sort
Returns the vector components sorted in ascending order.
.RS
.RE
.RE
.TP
.B \f[B]vector names\f[] ?\f[I]pattern\f[]?
\&...
.RS
.RE
.SH INSTANCE OPERATIONS
.PP
You can also use the vector\[aq]s Tcl command to query or modify it.
The general form is \f[I]vecName\f[] \f[I]operation\f[]
?\f[I]arg\f[]?...
Both \f[I]operation\f[] and its arguments determine the exact behavior
of the command.
The operations available for vectors are listed below.
.TP
.B \f[I]vecName\f[] \f[B]append\f[] \f[I]item\f[] ?\f[I]item\f[]?...
Appends the component values from \f[I]item\f[] to \f[I]vecName\f[].
\f[I]Item\f[] can be either the name of a vector or a list of numeric
values.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]binread\f[] \f[I]channel\f[] ?\f[I]length\f[]? ?\f[I]switches\f[]?
Reads binary values from a Tcl channel.
Values are either appended to the end of the vector or placed at a given
index (using the \f[B]\-at\f[] option), overwriting existing values.
Data is read until EOF is found on the channel or a specified number of
values \f[I]length\f[] are read (note that this is not necessarily the
same as the number of bytes).
The following switches are supported:
.RS
.TP
.B \-swap
Swap bytes and words.
The default endian is the host machine.
.RS
.RE
.TP
.B \-at \f[I]index\f[]
New values will start at vector index \f[I]index\f[].
This will overwrite any current values.
.RS
.RE
.TP
.B \-format \f[I]format\f[]
Specifies the format of the data.
\f[I]Format\f[] can be one of the following: "i1", "i2", "i4", "i8",
"u1, "u2", "u4", "u8", "r4", "r8", or "r16".
The number indicates the number of bytes required for each value.
The letter indicates the type: "i" for signed, "u" for unsigned, "r" or
real.
The default format is "r16".
.RS
.RE
.RE
.TP
.B \f[I]vecName\f[] \f[B]clear\f[]
Clears the element indices from the array variable associated with
\f[I]vecName\f[].
This doesn\[aq]t affect the components of the vector.
By default, the number of entries in the Tcl array doesn\[aq]t match the
number of components in the vector.
This is because its too expensive to maintain decimal strings for both
the index and value for each component.
Instead, the index and value are saved only when you read or write an
element with a new index.
This command removes the index and value strings from the array.
This is useful when the vector is large.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]delete\f[] \f[I]index\f[] ?\f[I]index\f[]?...
Deletes the \f[I]index\f[]th component from the vector \f[I]vecName\f[].
\f[I]Index\f[] is the index of the element to be deleted.
This is the same as unsetting the array variable element \f[I]index\f[].
The vector is compacted after all the indices have been deleted.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]dup\f[] \f[I]destName\f[]
Copies \f[I]vecName\f[] to \f[I]destName\f[].
\f[I]DestName\f[] is the name of a destination vector.
If a vector \f[I]destName\f[] already exists, it is overwritten with the
components of \f[I]vecName\f[].
Otherwise a new vector is created.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]expr\f[] \f[I]expression\f[]
Computes the expression and resets the values of the vector accordingly.
Both scalar and vector math operations are allowed.
All values in expressions are either real numbers or names of vectors.
All numbers are treated as one component vectors.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]length\f[] ?\f[I]newSize\f[]?
Queries or resets the number of components in \f[I]vecName\f[].
\f[I]NewSize\f[] is a number specifying the new size of the vector.
If \f[I]newSize\f[] is smaller than the current size of
\f[I]vecName\f[], \f[I]vecName\f[] is truncated.
If \f[I]newSize\f[] is greater, the vector is extended and the new
components are initialized to 0.0.
If no \f[I]newSize\f[] argument is present, the current length of the
vector is returned.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]merge\f[] \f[I]srcName\f[] ?\f[I]srcName\f[]?...
Merges the named vectors into a single vector.
The resulting vector is formed by merging the components of each source
vector one index at a time.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]notify\f[] \f[I]keyword\f[]
Controls how vector clients are notified of changes to the vector.
The exact behavior is determined by \f[I]keyword\f[].
.RS
.TP
.B always
Indicates that clients are to be notified immediately whenever the
vector is updated.
.RS
.RE
.TP
.B never
Indicates that no clients are to be notified.
.RS
.RE
.TP
.B whenidle
Indicates that clients are to be notified at the next idle point
whenever the vector is updated.
.RS
.RE
.TP
.B now
If any client notifications is currently pending, they are notified
immediately.
.RS
.RE
.TP
.B cancel
Cancels pending notifications of clients using the vector.
.RS
.RE
.TP
.B pending
Returns 1 if a client notification is pending, and 0 otherwise.
.RS
.RE
.RE
.TP
.B \f[I]vecName\f[] \f[B]offset\f[] ?\f[I]value\f[]?
Shifts the indices of the vector by the amount specified by
\f[I]value\f[].
\f[I]Value\f[] is an integer number.
If no \f[I]value\f[] argument is given, the current offset is returned.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]populate\f[] \f[I]destName\f[] ?\f[I]density\f[]?
Creates a vector \f[I]destName\f[] which is a superset of
\f[I]vecName\f[].
\f[I]DestName\f[] will include all the components of \f[I]vecName\f[],
in addition the interval between each of the original components will
contain a \f[I]density\f[] number of new components, whose values are
evenly distributed between the original components values.
This is useful for generating abscissas to be interpolated along a
spline.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]range\f[] \f[I]firstIndex\f[] ?\f[I]lastIndex\f[]?...
Returns a list of numeric values representing the vector components
between two indices.
Both \f[I]firstIndex\f[] and \f[I]lastIndex\f[] are indices representing
the range of components to be returned.
If \f[I]lastIndex\f[] is less than \f[I]firstIndex\f[], the components
are listed in reverse order.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]search\f[] \f[I]value\f[] ?\f[I]value\f[]?
Searches for a value or range of values among the components of
\f[I]vecName\f[].
If one \f[I]value\f[] argument is given, a list of indices of the
components which equal \f[I]value\f[] is returned.
If a second \f[I]value\f[] is also provided, then the indices of all
components which lie within the range of the two values are returned.
If no components are found, then "" is returned.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]set\f[] \f[I]item\f[]
Resets the components of the vector to \f[I]item\f[].
\f[I]Item\f[] can be either a list of numeric expressions or another
vector.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]seq\f[] \f[I]start\f[] ?\f[I]finish\f[]? ?\f[I]step\f[]?
Generates a sequence of values starting with the value \f[I]start\f[].
\f[I]Finish\f[] indicates the terminating value of the sequence.
The vector is automatically resized to contain just the sequence.
If three arguments are present, \f[I]step\f[] designates the interval.
.RS
.PP
With only two arguments (no \f[I]finish\f[] argument), the sequence will
continue until the vector is filled.
With one argument, the interval defaults to 1.0.
.RE
.TP
.B \f[I]vecName\f[] \f[B]sort\f[] ?\f[B]\-reverse\f[]? ?\f[I]argName\f[]?...
Sorts the vector \f[I]vecName\f[] in increasing order.
If the \f[B]\-reverse\f[] flag is present, the vector is sorted in
decreasing order.
If other arguments \f[I]argName\f[] are present, they are the names of
vectors which will be rearranged in the same manner as \f[I]vecName\f[].
Each vector must be the same length as \f[I]vecName\f[].
You could use this to sort the x vector of a graph, while still
retaining the same x,y coordinate pairs in a y vector.
.RS
.RE
.TP
.B \f[I]vecName\f[] \f[B]variable\f[] \f[I]varName\f[]
Maps a Tcl variable to the vector, creating another means for accessing
the vector.
The variable \f[I]varName\f[] can\[aq]t already exist.
This overrides any current variable mapping the vector may have.
.RS
.RE
.SH C LANGUAGE API
.PP
You can create, modify, and destroy vectors from C code, using library
.TP
.B routines.
You need to include the header file rbc.h.
It contains the
.RS
.RE
.TP
.B definition
of the structure \f[B]Rbc_Vector\f[], which represents the vector.
.RS
.RE
.TP
.B It appears
below.
.RS
.RE
.IP
.nf
\f[C]
typedef\ struct\ {
\ \ \ \ double\ *valueArr;
\ \ \ \ int\ numValues;
\ \ \ \ int\ arraySize;
\ \ \ \ double\ min,\ max;
}\ Rbc_Vector;
\f[]
.fi
.PP
The field \f[I]valueArr\f[] points to memory holding the vector
components.
The components are stored in a double precision array, whose size size
is represented by \f[I]arraySize\f[].
\f[I]NumValues\f[] is the length of vector.
The size of the array is always equal to or larger than the length of
the vector.
\f[I]Min\f[] and \f[I]max\f[] are minimum and maximum component values.
.SH LIBRARY ROUTINES
.PP
The following routines are available from C to manage vectors.
Vectors are identified by the vector name.
.PP
\f[B]Rbc_CreateVector\f[]
.PP
Synopsis:
.TP
.B int Rbc_CreateVector (\f[I]interp\f[], \f[I]vecName\f[], \f[I]length\f[], \f[I]vecPtrPtr\f[])
Tcl_Interp *\f[I]interp\f[]; char *\f[I]vecName\f[];
.PD 0
.P
.PD
int \f[I]length\f[];
.PD 0
.P
.PD
Rbc_Vector **\f[I]vecPtrPtr\f[];
.RS
.RE
.TP
.B Description:
Creates a new vector \f[I]vecName\f[] with a length of \f[I]length\f[].
\f[B]Rbc_CreateVector\f[] creates both a new Tcl command and array
variable \f[I]vecName\f[].
Neither a command nor variable named \f[I]vecName\f[] can already exist.
A pointer to the vector is placed into \f[I]vecPtrPtr\f[].
.RS
.RE
.TP
.B Results:
Returns TCL_OK if the vector is successfully created.
If \f[I]length\f[] is negative, a Tcl variable or command
\f[I]vecName\f[] already exists, or memory cannot be allocated for the
vector, then TCL_ERROR is returned and \f[I]interp\->result\f[] will
contain an error message.
.RS
.RE
.PP
\f[B]Rbc_DeleteVectorByName\f[]
.PP
Synopsis:
.TP
.B int Rbc_DeleteVectorByName (\f[I]interp\f[], \f[I]vecName\f[])
Tcl_Interp *\f[I]interp\f[]; char *\f[I]vecName\f[];
.RS
.RE
.TP
.B Description:
Removes the vector \f[I]vecName\f[].
\f[I]VecName\f[] is the name of a vector which must already exist.
Both the Tcl command and array variable \f[I]vecName\f[] are destroyed.
All clients of the vector will be notified immediately that the vector
has been destroyed.
.RS
.RE
.TP
.B Results:
Returns TCL_OK if the vector is successfully deleted.
If \f[I]vecName\f[] is not the name a vector, then TCL_ERROR is returned
and \f[I]interp\->result\f[] will contain an error message.
.RS
.RE
.PP
\f[B]Rbc_DeleteVector\f[]
.PP
Synopsis:
.TP
.B int Rbc_DeleteVector (\f[I]vecPtr\f[])
Rbc_Vector *\f[I]vecPtr\f[];
.RS
.RE
.TP
.B Description:
Removes the vector pointed to by \f[I]vecPtr\f[].
\f[I]VecPtr\f[] is a pointer to a vector, typically set by
\f[B]Rbc_GetVector\f[] or \f[B]Rbc_CreateVector\f[].
Both the Tcl command and array variable of the vector are destroyed.
All clients of the vector will be notified immediately that the vector
has been destroyed.
.RS
.RE
.TP
.B Results:
Returns TCL_OK if the vector is successfully deleted.
If \f[I]vecName\f[] is not the name a vector, then TCL_ERROR is returned
and \f[I]interp\->result\f[] will contain an error message.
.RS
.RE
.PP
\f[B]Rbc_GetVector\f[]
.PP
Synopsis:
.TP
.B int Rbc_GetVector (\f[I]interp\f[], \f[I]vecName\f[], \f[I]vecPtrPtr\f[])
Tcl_Interp *\f[I]interp\f[]; char *\f[I]vecName\f[];
.PD 0
.P
.PD
Rbc_Vector **\f[I]vecPtrPtr\f[];
.RS
.RE
.TP
.B Description:
Retrieves the vector \f[I]vecName\f[].
\f[I]VecName\f[] is the name of a vector which must already exist.
\f[I]VecPtrPtr\f[] will point be set to the address of the vector.
.RS
.RE
.TP
.B Results:
Returns TCL_OK if the vector is successfully retrieved.
If \f[I]vecName\f[] is not the name of a vector, then TCL_ERROR is
returned and \f[I]interp\->result\f[] will contain an error message.
.RS
.RE
.PP
\f[B]Rbc_ResetVector\f[]
.PP
Synopsis:
.PP
int \f[B]Rbc_ResetVector\f[] (\f[I]vecPtr\f[], \f[I]dataArr\f[],
.TP
.B \f[I]numValues\f[], \f[I]arraySize\f[], \f[I]freeProc\f[])
Rbc_Vector *\f[I]vecPtr\f[]; double *\f[I]dataArr\f[];
.PD 0
.P
.PD
int *\f[I]numValues\f[];
.PD 0
.P
.PD
int *\f[I]arraySize\f[];
.PD 0
.P
.PD
Tcl_FreeProc *\f[I]freeProc\f[];
.RS
.RE
.TP
.B Description:
Resets the components of the vector pointed to by \f[I]vecPtr\f[].
Calling \f[B]Rbc_ResetVector\f[] will trigger the vector to dispatch
notifications to its clients.
\f[I]DataArr\f[] is the array of doubles which represents the vector
data.
\f[I]NumValues\f[] is the number of elements in the array.
\f[I]ArraySize\f[] is the actual size of the array (the array may be
bigger than the number of values stored in it).
\f[I]FreeProc\f[] indicates how the storage for the vector component
array (\f[I]dataArr\f[]) was allocated.
It is used to determine how to reallocate memory when the vector is
resized or destroyed.
It must be TCL_DYNAMIC, TCL_STATIC, TCL_VOLATILE, or a pointer to a
function to free the memory allocated for the vector array.
If \f[I]freeProc\f[] is TCL_VOLATILE, it indicates that \f[I]dataArr\f[]
must be copied and saved.
If \f[I]freeProc\f[] is TCL_DYNAMIC, it indicates that \f[I]dataArr\f[]
was dynamically allocated and that Tcl should free \f[I]dataArr\f[] if
necessary.
Static indicates that nothing should be done to release storage for
\f[I]dataArr\f[].
.RS
.RE
.TP
.B Results:
Returns TCL_OK if the vector is successfully resized.
If \f[I]newSize\f[] is negative, a vector \f[I]vecName\f[] does not
exist, or memory cannot be allocated for the vector, then TCL_ERROR is
returned and \f[I]interp\->result\f[] will contain an error message.
.RS
.RE
.PP
\f[B]Rbc_ResizeVector\f[]
.PP
Synopsis:
.TP
.B int Rbc_ResizeVector (\f[I]vecPtr\f[], \f[I]newSize\f[])
Rbc_Vector *\f[I]vecPtr\f[]; int \f[I]newSize\f[];
.RS
.RE
.TP
.B Description:
Resets the length of the vector pointed to by \f[I]vecPtr\f[] to
\f[I]newSize\f[].
If \f[I]newSize\f[] is smaller than the current size of the vector, it
is truncated.
If \f[I]newSize\f[] is greater, the vector is extended and the new
components are initialized to 0.0.
Calling \f[B]Rbc_ResetVector\f[] will trigger the vector to dispatch
notifications.
.RS
.RE
.TP
.B Results:
Returns TCL_OK if the vector is successfully resized.
If \f[I]newSize\f[] is negative or memory can not be allocated for the
vector, then TCL_ERROR is returned and \f[I]interp\->result\f[] will
contain an error message.
.RS
.RE
.PP
\f[B]Rbc_VectorExists\f[]
.PP
Synopsis:
.TP
.B int Rbc_VectorExists (\f[I]interp\f[], \f[I]vecName\f[])
Tcl_Interp *\f[I]interp\f[]; char *\f[I]vecName\f[];
.RS
.RE
.TP
.B Description:
Indicates if a vector named \f[I]vecName\f[] exists in \f[I]interp\f[].
.RS
.RE
.TP
.B Results:
Returns 1 if a vector \f[I]vecName\f[] exists and 0 otherwise.
.RS
.RE
.PP
If your application needs to be notified when a vector changes, it can
allocate a unique \f[I]client\f[] \f[I]identifier\f[] for itself.
Using this identifier, you can then register a call\-back to be made
whenever the vector is updated or destroyed.
By default, the call\-backs are made at the next idle point.
This can be changed to occur at the time the vector is modified.
An application can allocate more than one identifier for any vector.
When the client application is done with the vector, it should free the
identifier.
.PP
The call\-back routine must of the following type.
.TP
.B typedef void (Rbc_VectorChangedProc) (Tcl_Interp *\f[I]interp\f[],
ClientData \f[I]clientData\f[], Rbc_VectorNotify \f[I]notify\f[]);
.RS
.RE
.PP
\f[I]ClientData\f[] is passed to this routine whenever it is called.
You can use this to pass information to the call\-back.
The \f[I]notify\f[] argument indicates whether the vector has been
updated of destroyed.
It is an enumerated type.
.TP
.B typedef enum {
RBC_VECTOR_NOTIFY_UPDATE=1, RBC_VECTOR_NOTIFY_DESTROY=2
.PD 0
.P
.PD
} \f[B]Rbc_VectorNotify\f[];
.RS
.RE
.PP
\f[B]Rbc_AllocVectorId\f[]
.PP
Synopsis:
.TP
.B Rbc_VectorId Rbc_AllocVectorId (\f[I]interp\f[], \f[I]vecName\f[])
Tcl_Interp *\f[I]interp\f[]; char *\f[I]vecName\f[];
.RS
.RE
.TP
.B Description:
Allocates an client identifier for with the vector \f[I]vecName\f[].
This identifier can be used to specify a call\- back which is triggered
when the vector is updated or destroyed.
.RS
.RE
.TP
.B Results:
Returns a client identifier if successful.
If \f[I]vecName\f[] is not the name of a vector, then NULL is returned
and \f[I]interp\->result\f[] will contain an error message.
.RS
.RE
.PP
\f[B]Rbc_GetVectorById\f[]
.PP
Synopsis:
.TP
.B int Rbc_GetVector (\f[I]interp\f[], \f[I]clientId\f[], \f[I]vecPtrPtr\f[])
Tcl_Interp *\f[I]interp\f[]; Rbc_VectorId \f[I]clientId\f[];
.PD 0
.P
.PD
Rbc_Vector **\f[I]vecPtrPtr\f[];
.RS
.RE
.TP
.B Description:
Retrieves the vector used by \f[I]clientId\f[].
\f[I]ClientId\f[] is a valid vector client identifier allocated by
\f[B]Rbc_AllocVectorId\f[].
\f[I]VecPtrPtr\f[] will point be set to the address of the vector.
.RS
.RE
.TP
.B Results:
Returns TCL_OK if the vector is successfully retrieved.
.RS
.RE
.PP
\f[B]Rbc_SetVectorChangedProc\f[]
.PP
Synopsis:
.TP
.B void Rbc_SetVectorChangedProc (\f[I]clientId\f[], \f[I]proc\f[], \f[I]clientData\f[]);
Rbc_VectorId \f[I]clientId\f[]; Rbc_VectorChangedProc *\f[I]proc\f[];
ClientData *\f[I]clientData\f[];
.RS
.RE
.TP
.B Description:
Specifies a call\-back routine to be called whenever the vector
associated with \f[I]clientId\f[] is updated or deleted.
\f[I]Proc\f[] is a pointer to call\-back routine and must be of the type
\f[B]Rbc_VectorChangedProc\f[].
\f[I]ClientData\f[] is a one\- word value to be passed to the routine
when it is invoked.
If \f[I]proc\f[] is NULL, then the client is not notified.
.RS
.RE
.TP
.B Results:
The designated call\-back procedure will be invoked when the vector is
updated or destroyed.
.RS
.RE
.PP
\f[B]Rbc_FreeVectorId\f[]
.PP
Synopsis:
.TP
.B void Rbc_FreeVectorId (\f[I]clientId\f[]);
Rbc_VectorId \f[I]clientId\f[];
.RS
.RE
.TP
.B Description:
Frees the client identifier.
Memory allocated for the identifier is released.
The client will no longer be notified when the vector is modified.
.RS
.RE
.TP
.B Results:
The designated call\-back procedure will be no longer be invoked when
the vector is updated or destroyed.
.RS
.RE
.PP
\f[B]Rbc_NameOfVectorId\f[]
.PP
Synopsis:
.TP
.B char *Rbc_NameOfVectorId (\f[I]clientId\f[]);
Rbc_VectorId \f[I]clientId\f[];
.RS
.RE
.TP
.B Description:
Retrieves the name of the vector associated with the client identifier
\f[I]clientId\f[].
.RS
.RE
.TP
.B Results:
Returns the name of the vector associated with \f[I]clientId\f[].
If \f[I]clientId\f[] is not an identifier or the vector has been
destroyed, NULL is returned.
.RS
.RE
.PP
\f[B]Rbc_InstallIndexProc\f[]
.PP
Synopsis:
.TP
.B void Rbc_InstallIndexProc (\f[I]indexName\f[], \f[I]procPtr\f[])
char *\f[I]indexName\f[]; Rbc_VectorIndexProc *\f[I]procPtr\f[];
.RS
.RE
.TP
.B Description:
Registers a function to be called to retrieved the index
\f[I]indexName\f[] from the vector\[aq]s array variable.
.RS
.PP
typedef double Rbc_VectorIndexProc(Vector *vecPtr);
.PP
The function will be passed a pointer to the vector.
The function must return a double representing the value at the index.
.RE
.TP
.B Results:
The new index is installed into the vector.
.RS
.RE
.SH C API EXAMPLE
.PP
The following example opens a file of binary data and stores it in an
array of doubles.
The array size is computed from the size of the file.
If the vector "data" exists, calling \f[B]Rbc_VectorExists\f[],
\f[B]Rbc_GetVector\f[] is called to get the pointer to the vector.
Otherwise the routine \f[B]Rbc_CreateVector\f[] is called to create a
new vector and returns a pointer to it.
Just like the Tcl interface, both a new Tcl command and array variable
are created when a new vector is created.
It doesn\[aq]t make any difference what the initial size of the vector
is since it will be reset shortly.
The vector is updated when bc_ResetVector is called.
Rbc_ResetVector makes the changes visible to the Tcl interface and other
vector clients (such as a graph widget).
.IP
.nf
\f[C]
#include\ <tcl.h>
#include\ <rbc.h>
Rbc_Vector\ *vecPtr;
double\ *newArr;
FILE\ *f;
struct\ stat\ statBuf;
int\ numBytes,\ numValues;

f\ =\ fopen("binary.dat",\ "r");
fstat(fileno(f),\ &statBuf);
numBytes\ =\ (int)statBuf.st_size;

/*\ Allocate\ an\ array\ big\ enough\ to\ hold\ all\ the\ data\ */
newArr\ =\ (double\ *)malloc(numBytes);
numValues\ =\ numBytes\ /\ sizeof(double);
fread((void\ *)newArr,\ numValues,\ sizeof(double),\ f);
fclose(f);

if\ (Rbc_VectorExists(interp,\ "data"))\ \ {
\ \ \ \ if\ (Rbc_GetVector(interp,\ "data",\ &vecPtr)\ !=\ TCL_OK)\ {
\ \ return\ TCL_ERROR;
\ \ \ \ }
}\ else\ {
\ \ \ if\ (Rbc_CreateVector(interp,\ "data",\ 0,\ &vecPtr)\ !=\ TCL_OK)\ {
\ \ return\ TCL_ERROR;
\ \ \ }
}
/*
\ *\ Reset\ the\ vector.\ Clients\ will\ be\ notified\ when\ Tk\ is\ idle.
\ *\ TCL_DYNAMIC\ tells\ the\ vector\ to\ free\ the\ memory\ allocated
\ *\ if\ it\ needs\ to\ reallocate\ or\ destroy\ the\ vector.
\ */
if\ (Rbc_ResetVector(vecPtr,\ newArr,\ numValues,\ numValues,
\ \ TCL_DYNAMIC)\ !=\ TCL_OK)\ {
\ \ \ \ return\ TCL_ERROR;
}
\f[]
.fi
.SH INCOMPATIBILITIES
.PP
In previous versions, if the array variable isn\[aq]t global (i.e.
local to a Tcl procedure), the vector is automatically destroyed when
the procedure returns.
.IP
.nf
\f[C]
proc\ doit\ {}\ {
\ \ \ \ #\ Temporary\ vector\ x
\ \ \ \ vector\ x(10)
\ \ \ \ set\ x(9)\ 2.0
\ \ \ \ \ \ ...
}
\f[]
.fi
.PP
This has changed.
Variables are not automatically destroyed when their variable is unset.
You can restore the old behavior by setting the "\-watchunset" switch.
.SH KEYWORDS
.PP
vector, graph, widget
