.\" Automatically generated by Pandoc 1.17.1
.\"
.ad l
.TH "tree" "n" "" "RBC(0.2)" "RBC Built-In Commands"
.hy
.SH NAME
.PP
tree \- Create and manage tree data objects.
.SH SYNOPSIS
.PP
\f[B]rbc::tree create\f[] ?\f[I]treeName\f[]?
.PP
\f[B]rbc::tree destroy\f[] \f[I]treeName\f[]...
.PP
\f[B]rbc::tree names\f[] ?\f[I]pattern\f[]?
.SH DESCRIPTION
.PP
The \f[B]tree\f[] command creates tree data objects.
A \f[I]tree\f[] \f[I]object\f[] is general ordered tree of nodes.
Each node has both a label and a key\-value list of data.
Data can be heterogeneous, since nodes do not have to contain the same
data keys.
It is associated with a Tcl command that you can use to access and
modify the its structure and data.
Tree objects can also be managed via a C API.
.SH INTRODUCTION
.SH EXAMPLE
.SH SYNTAX
.TP
.B \f[B]tree create\f[] ?\f[I]treeName\f[]?
Creates a new tree object.
The name of the new tree is returned.
If no \f[I]treeName\f[] argument is present, then the name of the tree
is automatically generated in the form "tree0", "tree1", etc.
If the substring "#auto" is found in \f[I]treeName\f[], it is
automatically substituted by a generated name.
For example, the name .foo.#auto.bar will be translated to
.foo.tree0.bar.
.RS
.PP
A new Tcl command (by the same name as the tree) is also created.
Another Tcl command or tree object can not already exist as
\f[I]treeName\f[].
If the Tcl command is deleted, the tree will also be freed.
The new tree will contain just the root node.
Trees are by default, created in the current namespace, not the global
namespace, unless \f[I]treeName\f[] contains a namespace qualifier, such
as "fred::myTree".
.RE
.TP
.B \f[B]tree destroy\f[] \f[I]treeName\f[]...
Releases one of more trees.
The Tcl command associated with \f[I]treeName\f[] is also removed.
Trees are reference counted.
The internal tree data object isn\[aq]t destroyed until no one else is
using the tree.
.RS
.RE
.TP
.B \f[B]tree names\f[] ?\f[I]pattern\f[]?
Returns the names of all tree objects.
if a \f[I]pattern\f[] argument is given, then the only those trees whose
name matches pattern will be listed.
.RS
.RE
.SH NODE IDS AND TAGS
.PP
Nodes in a tree object may be referred in either of two ways: by id or
by tag.
Each node has a unique serial number or id that is assigned to that node
when it\[aq]s created.
The id of an node never changes and id numbers are not re\-used.
.PP
A node may also have any number of tags associated with it.
A tag is just a string of characters, and it may take any form except
that of an integer.
For example, "x123" is valid, but "123" isn\[aq]t.
The same tag may be associated with many different nodes.
This is commonly done to group nodes in various interesting ways.
.PP
There are two built\-in tags: The tag \f[B]all\f[] is implicitly
associated with every node in the tree.
It may be used to invoke operations on all the nodes in the tree.
The tag \f[B]root\f[] is managed automatically by the tree object.
It applies to the node currently set as root.
.PP
When specifying nodes in tree object commands, if the specifier is an
integer then it is assumed to refer to the single node with that id.
If the specifier is not an integer, then it is assumed to refer to all
of the nodes in the tree that have a tag matching the specifier.
The symbol \f[I]node\f[] is used below to indicate that an argument
specifies either an id that selects a single node or a tag that selects
zero or more nodes.
Many tree commands only operate on a single node at a time; if
\f[I]node\f[] is specified in a way that names multiple items, then an
error "refers to more than one node" is generated.
.SH NODE MODIFIERS
.PP
You can also specify node in relation to another node by appending one
or more modifiers to the node id or tag.
A modifier refers to a node in relation to the specified node.
For example, "root\->firstchild" selects the first subtree of the root
node.
.PP
The following modifiers are available:
.TP
.B firstchild
Selects the first child of the node.
.RS
.RE
.TP
.B lastchild
Selects the last child of the node.
.RS
.RE
.TP
.B next
Selects the next node in preorder to the node.
.RS
.RE
.TP
.B nextsibling
Selects the next sibling of the node.
.RS
.RE
.TP
.B parent
Selects the parent of the node.
.RS
.RE
.TP
.B previous
Selects the previous node in preorder to the node.
.RS
.RE
.TP
.B prevsibling
Selects the previous sibling of the node.
.RS
.RE
.TP
.B "\f[I]label\f[]"
Selects the node whose label is \f[I]label\f[].
Enclosing \f[I]label\f[] in quotes indicates to always search for a node
by its label (for example, even if the node is labeled "parent").
.RS
.RE
.PP
It\[aq]s an error the node can\[aq]t be found.
For example, \f[B]lastchild\f[] and \f[B]firstchild\f[] will generate
errors if the node has no children.
The exception to this is the \f[B]index\f[] operation.
You can use \f[B]index\f[] to test if a modifier is valid.
.SH TREE OPERATIONS
.PP
Once you create a tree object, you can use its Tcl command to query or
modify it.
The general form is \f[I]treeName\f[] \f[I]operation\f[]
?\f[I]arg\f[]?...
Both \f[I]operation\f[] and its arguments determine the exact behavior
of the command.
The operations available for trees are listed below.
.TP
.B \f[I]treeName\f[] \f[B]ancestor\f[] \f[I]node1\f[] \f[I]node2\f[]
Returns the mutual ancestor of the two nodes \f[I]node1\f[] and
\f[I]node2\f[].
The ancestor can be one of the two nodes.
For example, if \f[I]node1\f[] and \f[I]node2\f[] are the same nodes,
their ancestor is \f[I]node1\f[].
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]apply\f[] \f[I]node\f[] ?\f[I]switches\f[]?
Runs commands for all nodes matching the criteria given by
\f[I]switches\f[] for the subtree designated by \f[I]node\f[].
By default all nodes match, but you can set switches to narrow the
match.
This operation differs from \f[B]find\f[] in two ways: 1) Tcl commands
can be invoked both pre\- and post\-traversal of a node and 2) the tree
is always traversed in depth first order.
.RS
.PP
The \f[B]\-exact\f[], \f[B]\-glob\f[], and \f[B]\-regexp\f[] switches
indicate both what kind of pattern matching to perform and the pattern.
By default each pattern will be compared with the node label.
You can set more than one of these switches.
If any of the patterns match (logical or), the node matches.
If the \f[B]\-key\f[] switch is used, it designates the data field to be
matched.
.PP
The valid switches are listed below:
.TP
.B \-depth \f[I]number\f[]
Descend at most \f[I]number\f[] (a non\-negative integer) levels If
\f[I]number\f[] is 1 this means only apply the tests to the children of
\f[I]node\f[].
.RS
.RE
.TP
.B \-exact \f[I]string\f[]
Matches each node using \f[I]string\f[].
The node must match \f[I]string\f[] exactly.
.RS
.RE
.TP
.B \-glob \f[I]string\f[]
Test each node to \f[I]string\f[] using global pattern matching.
Matching is done in a fashion similar to that used by the C\-shell.
.RS
.RE
.TP
.B \-invert
Select non\-matching nodes.
Any node that \f[I]doesn\[aq]t\f[] match the given criteria will be
selected.
.RS
.RE
.TP
.B \-key
\f[I]key\f[] If pattern matching is selected (using the
\f[B]\-exact\f[], \f[B]\-glob\f[], or \f[B]\-regexp\f[] switches),
compare the values of the data field keyed by \f[I]key\f[] instead of
the node\[aq]s label.
If no pattern matching switches are set, then any node with this data
key will match.
.RS
.RE
.TP
.B \-leafonly
Only test nodes with no children.
.RS
.RE
.TP
.B \-nocase
Ignore case when matching patterns.
.RS
.RE
.TP
.B \-path
Use the node\[aq]s full path when comparing nodes.
The node\[aq]s full path is a list of labels, starting from the root of
each ancestor and the node itself.
.RS
.RE
.TP
.B \-precommand \f[I]command\f[]
Invoke \f[I]command\f[] for each matching node.
Before \f[I]command\f[] is invoked, the id of the node is appended.
You can control processing by the return value of \f[I]command\f[].
If \f[I]command\f[] generates an error, processing stops and the
\f[B]find\f[] operation returns an error.
But if \f[I]command\f[] returns \f[B]break\f[], then processing stops,
no error is generated.
If \f[I]command\f[] returns \f[B]continue\f[], then processing stops on
that subtree and continues on the next.
.RS
.RE
.TP
.B \-postcommand \f[I]command\f[]
Invoke \f[I]command\f[] for each matching node.
Before \f[I]command\f[] is invoked, the id of the node is appended.
You can control processing by the return value of \f[I]command\f[].
If \f[I]command\f[] generates an error, processing stops and the
\f[B]find\f[] operation returns an error.
But if \f[I]command\f[] returns \f[B]break\f[], then processing stops,
no error is generated.
If \f[I]command\f[] returns \f[B]continue\f[], then processing stops on
that subtree and continues on the next.
.RS
.RE
.TP
.B \-regexp \f[I]string\f[]
Test each node using \f[I]string\f[] as a regular expression pattern.
.RS
.RE
.TP
.B \-tag \f[I]string\f[]
Only test nodes that have the tag \f[I]string\f[].
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]attach\f[] \f[I]treeObject\f[]
Attaches to an existing tree object \f[I]treeObject\f[].
This is for cases where the tree object was previously created via the C
API.
The current tree associated with \f[I]treeName\f[] is discarded.
In addition, the current set of tags, notifier events, and traces are
removed.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]children\f[] \f[I]node\f[]
Returns a list of children for \f[I]node\f[].
If \f[I]node\f[] is a leaf, then an empty string is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]copy\f[] \f[I]srcNode\f[] ?\f[I]destTree\f[]? \f[I]parentNode\f[] ?\f[I]switches\f[]?
Copies \f[I]srcNode\f[] into \f[I]parentNode\f[].
Both nodes \f[I]srcNode\f[] and \f[I]parentNode\f[] must already exist.
The id of the new node is returned.
You can copy from one tree to another.
If a \f[I]destTree\f[] argument is present, it indicates the name of the
destination tree.
By default both the source and destination trees are the same.
The valid \f[I]switches\f[] are listed below:
.RS
.TP
.B \-label \f[I]string\f[]
Label \f[I]destNode\f[] as \f[I]string\f[].
By default, \f[I]destNode\f[] has the same label as \f[I]srcNode\f[].
.RS
.RE
.TP
.B \-overwrite
Overwrite nodes that already exist.
Normally nodes are always created, even if there already exists a node
by the same name.
This switch indicates to add or overwrite the node\[aq]s data fields.
.RS
.RE
.TP
.B \-recurse
Recursively copy all the subtrees of \f[I]srcNode\f[] as well.
In this case, \f[I]srcNode\f[] can\[aq]t be an ancestor of
\f[I]destNode\f[] as it would result in a cyclic copy.
.RS
.RE
.TP
.B \-tags
Copy tag inforation.
Normally the following node is copied: its label and data fields.
This indicates to copy tags as well.
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]degree\f[] \f[I]node\f[]
Returns the number of children of \f[I]node\f[].
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]delete\f[] \f[I]node\f[]...
Recursively deletes one or more nodes from the tree.
The node and all its descendants are removed.
The one exception is the root node.
In this case, only its descendants are removed.
The root node will remain.
Any tags or traces on the nodes are released.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]depth\f[] \f[I]node\f[]
Returns the depth of the node.
The depth is the number of steps from the node to the root of the tree.
The depth of the root node is 0.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]dump\f[] \f[I]node\f[]
Returns a list of the paths and respective data for \f[I]node\f[] and
its descendants.
The subtree designated by \f[I]node\f[] is traversed returning the
following information for each node: 1) the node\[aq]s path relative to
\f[I]node\f[], 2) a sublist key value pairs representing the node\[aq]s
data fields, and 3) a sublist of tags.
This list returned can be used later to copy or restore the tree with
the \f[B]restore\f[] operation.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]dumpfile\f[] \f[I]node\f[] \f[I]fileName\f[]
Writes a list of the paths and respective data for \f[I]node\f[] and its
descendants to the given file \f[I]fileName\f[].
The subtree designated by \f[I]node\f[] is traversed returning the
following information for each node: 1) the node\[aq]s path relative to
\f[I]node\f[], 2) a sublist key value pairs representing the node\[aq]s
data fields, and 3) a sublist of tags.
This list returned can be used later to copy or restore the tree with
the \f[B]restore\f[] operation.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]exists\f[] \f[I]node\f[] ?\f[I]key\f[]?
Indicates if \f[I]node\f[] exists in the tree.
If a \f[I]key\f[] argument is present then the command also indicates if
the named data field exists.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]find\f[] \f[I]node\f[] ?\f[I]switches\f[]?
Finds for all nodes matching the criteria given by \f[I]switches\f[] for
the subtree designated by \f[I]node\f[].
A list of the selected nodes is returned.
By default all nodes match, but you can set switches to narrow the
match.
.RS
.PP
The \f[B]\-exact\f[], \f[B]\-glob\f[], and \f[B]\-regexp\f[] switches
indicate both what kind of pattern matching to perform and the pattern.
By default each pattern will be compared with the node label.
You can set more than one of these switches.
If any of the patterns match (logical or), the node matches.
If the \f[B]\-key\f[] switch is used, it designates the data field to be
matched.
.PP
The order in which the nodes are traversed is controlled by the
\f[B]\-order\f[] switch.
The possible orderings are \f[B]preorder\f[], \f[B]postorder\f[],
\f[B]inorder\f[], and \f[B]breadthfirst\f[].
The default is \f[B]postorder\f[].
.PP
The valid switches are listed below:
.TP
.B \-addtag \f[I]string\f[]
Add the tag \f[I]string\f[] to each selected node.
.RS
.RE
.TP
.B \-count \f[I]number\f[]
Stop processing after \f[I]number\f[] (a positive integer) matches.
.RS
.RE
.TP
.B \-depth \f[I]number\f[]
Descend at most \f[I]number\f[] (a non\-negative integer) levels If
\f[I]number\f[] is 1 this means only apply the tests to the children of
\f[I]node\f[].
.RS
.RE
.TP
.B \-exact \f[I]string\f[]
Matches each node using \f[I]string\f[].
The node must match \f[I]string\f[] exactly.
.RS
.RE
.TP
.B \-exec \f[I]command\f[]
Invoke \f[I]command\f[] for each matching node.
Before \f[I]command\f[] is invoked, the id of the node is appended.
You can control processing by the return value of \f[I]command\f[].
If \f[I]command\f[] generates an error, processing stops and the
\f[B]find\f[] operation returns an error.
But if \f[I]command\f[] returns \f[B]break\f[], then processing stops,
no error is generated.
If \f[I]command\f[] returns \f[B]continue\f[], then processing stops on
that subtree and continues on the next.
.RS
.RE
.TP
.B \-glob \f[I]string\f[]
Test each node to \f[I]string\f[] using global pattern matching.
Matching is done in a fashion similar to that used by the C\-shell.
.RS
.RE
.TP
.B \-invert
Select non\-matching nodes.
Any node that \f[I]doesn\[aq]t\f[] match the given criteria will be
selected.
.RS
.RE
.TP
.B \-key
\f[I]key\f[] Compare the values of the data field keyed by \f[I]key\f[]
instead of the node\[aq]s label.
If no pattern is given (\f[B]\-exact\f[], \f[B]\-glob\f[], or
\f[B]\-regexp\f[] switches), then any node with this data key will
match.
.RS
.RE
.TP
.B \-leafonly
Only test nodes with no children.
.RS
.RE
.TP
.B \-nocase
Ignore case when matching patterns.
.RS
.RE
.TP
.B \-order \f[I]string\f[]
Traverse the tree and process nodes according to \f[I]string\f[].
\f[I]String\f[] can be one of the following:
.RS
.TP
.B breadthfirst
Process the node and the subtrees at each sucessive level.
Each node on a level is processed before going to the next level.
.RS
.RE
.TP
.B inorder
Recursively process the nodes of the first subtree, the node itself, and
any the remaining subtrees.
.RS
.RE
.TP
.B postorder
Recursively process all subtrees before the node.
.RS
.RE
.TP
.B preorder
Recursively process the node first, then any subtrees.
.RS
.RE
.RE
.TP
.B \-path
Use the node\[aq]s full path when comparing nodes.
.RS
.RE
.TP
.B \-regexp \f[I]string\f[]
Test each node using \f[I]string\f[] as a regular expression pattern.
.RS
.RE
.TP
.B \-tag \f[I]string\f[]
Only test nodes that have the tag \f[I]string\f[].
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]findchild\f[] \f[I]node\f[] \f[I]label\f[]
Searches for a child node Ilabel in \f[I]node\f[].
The id of the child node is returned if found.
Otherwise \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]firstchild\f[] \f[I]node\f[]
Returns the id of the first child in the \f[I]node\f[]\[aq]s list of
subtrees.
If \f[I]node\f[] is a leaf (has no children), then \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]get\f[] \f[I]node\f[] ?\f[I]key\f[]? ?\f[I]defaultValue\f[]?
Returns a list of key\-value pairs of data for the node.
If \f[I]key\f[] is present, then onlyx the value for that particular
data field is returned.
It\[aq]s normally an error if \f[I]node\f[] does not contain the data
field \f[I]key\f[].
But if you provide a \f[I]defaultValue\f[] argument, this value is
returned instead (\f[I]node\f[] will still not contain \f[I]key\f[]).
This feature can be used to access a data field of \f[I]node\f[] without
first testing if it exists.
This operation may trigger \f[B]read\f[] data traces.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]index\f[] \f[I]node\f[]
Returns the id of \f[I]node\f[].
If \f[I]node\f[] is a tag, it can only specify one node.
If \f[I]node\f[] does not represent a valid node id or tag, or has
modifiers that are invalid, then \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]insert\f[] \f[I]parent\f[] ?\f[I]switches\f[]?
Inserts a new node into parent node \f[I]parent\f[].
The id of the new node is returned.
The following switches are available:
.RS
.TP
.B \-after \f[I]child\f[]
Position \f[I]node\f[] after \f[I]child\f[].
The node \f[I]child\f[] must be a child of \f[I]parent\f[].
.RS
.RE
.TP
.B \-at \f[I]number\f[]
Inserts the node into \f[I]parent\f[]\[aq]s list of children at position
\f[I]number\f[].
The default is to append \f[I]node\f[].
.RS
.RE
.TP
.B \-before \f[I]child\f[]
Position \f[I]node\f[] before \f[I]child\f[].
The node \f[I]child\f[] must be a child of \f[I]parent\f[].
.RS
.RE
.TP
.B \-data \f[I]dataList\f[]
Sets the value for each data field in \f[I]dataList\f[] for the new
node.
\f[I]DataList\f[] is a list of key\-value pairs.
.RS
.RE
.TP
.B \-label \f[I]string\f[]
Designates the labels of the node as \f[I]string\f[].
By default, nodes are labeled as node0, node1, etc.
.RS
.RE
.TP
.B \-node
\f[I]id\f[] Designates the id for the node.
Normally new ids are automatically generated.
This allows you to create a node with a specific id.
It is an error if the id is already used by another node in the tree.
.RS
.RE
.TP
.B \-tags \f[I]tagList\f[]
Adds each tag in \f[I]tagList\f[] to the new node.
\f[I]TagList\f[] is a list of tags, so be careful if a tag has embedded
space.
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]is\f[] \f[I]property\f[] \f[I]args\f[]
Indicates the property of a node.
Both \f[I]property\f[] and \f[I]args\f[] determine the property being
tested.
Returns 1 if true and 0 otherwise.
The following \f[I]property\f[] and \f[I]args\f[] are valid:
.RS
.TP
.B ancestor \f[I]node1\f[] \f[I]node2\f[]
Indicates if \f[I]node1\f[] is an ancestor of \f[I]node2\f[].
.RS
.RE
.TP
.B before \f[I]node1\f[] \f[I]node2\f[]
Indicates if \f[I]node1\f[] is before \f[I]node2\f[] in depth first
traversal.
.RS
.RE
.TP
.B leaf \f[I]node\f[]
Indicates if \f[I]node\f[] is a leaf (it has no subtrees).
.RS
.RE
.TP
.B root \f[I]node\f[]
Indicates if \f[I]node\f[] is the designated root.
This can be changed by the \f[B]root\f[] operation.
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]label\f[] \f[I]node\f[] ?\f[I]newLabel\f[]?
Returns the label of the node designated by \f[I]node\f[].
If \f[I]newLabel\f[] is present, the node is relabeled using it as the
new label.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]lastchild\f[] \f[I]node\f[]
Returns the id of the last child in the \f[I]node\f[]\[aq]s list of
subtrees.
If \f[I]node\f[] is a leaf (has no children), then \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]move\f[] \f[I]node\f[] \f[I]newParent\f[] ?\f[I]switches\f[]?
Moves \f[I]node\f[] into \f[I]newParent\f[].
\f[I]Node\f[] is appended to the list children of \f[I]newParent\f[].
\f[I]Node\f[] can not be an ancestor of \f[I]newParent\f[].
The valid flags for \f[I]switches\f[] are described below.
.RS
.TP
.B \-after \f[I]child\f[]
Position \f[I]node\f[] after \f[I]child\f[].
The node \f[I]child\f[] must be a child of \f[I]newParent\f[].
.RS
.RE
.TP
.B \-at \f[I]number\f[]
Inserts \f[I]node\f[] into \f[I]parent\f[]\[aq]s list of children at
position \f[I]number\f[].
The default is to append the node.
.RS
.RE
.TP
.B \-before \f[I]child\f[]
Position \f[I]node\f[] before \f[I]child\f[].
The node \f[I]child\f[] must be a child of \f[I]newParent\f[].
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]next\f[] \f[I]node\f[]
Returns the next node from \f[I]node\f[] in a preorder traversal.
If \f[I]node\f[] is the last node in the tree, then \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]nextsibling\f[] \f[I]node\f[]
Returns the node representing the next subtree from \f[I]node\f[] in its
parent\[aq]s list of children.
If \f[I]node\f[] is the last child, then \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]notify\f[] \f[I]args\f[]
Manages notification events that indicate that the tree structure has
been changed.
See the \f[B]NOTIFY OPERATIONS\f[] section below.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]parent\f[] \f[I]node\f[]
Returns the parent node of \f[I]node\f[].
If \f[I]node\f[] is the root of the tree, then \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]path\f[] \f[I]node\f[]
Returns the full path (from root) of \f[I]node\f[].
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]position\f[] \f[I]node\f[]
Returns the position of the node in its parent\[aq]s list of children.
Positions are numbered from 0.
The position of the root node is always 0.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]previous\f[] \f[I]node\f[]
Returns the previous node from \f[I]node\f[] in a preorder traversal.
If \f[I]node\f[] is the root of the tree, then \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]prevsibling\f[] \f[I]node\f[]
Returns the node representing the previous subtree from \f[I]node\f[] in
its parent\[aq]s list of children.
If \f[I]node\f[] is the first child, then \-1 is returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]restore\f[] \f[I]node\f[] \f[I]dataString\f[] \f[I]switches\f[]
Performs the inverse function of the \f[B]dump\f[] operation, restoring
nodes to the tree.
The format of \f[I]dataString\f[] is exactly what is returned by the
\f[B]dump\f[] operation.
It\[aq]s a list containing information for each node to be restored.
The information consists of 1) the relative path of the node, 2) a
sublist of key value pairs representing the node\[aq]s data, and 3) a
list of tags for the node.
Nodes are created starting from \f[I]node\f[].
Nodes can be listed in any order.
If a node\[aq]s path describes ancestor nodes that do not already exist,
they are automatically created.
The valid \f[I]switches\f[] are listed below:
.RS
.TP
.B \-overwrite
Overwrite nodes that already exist.
Normally nodes are always created, even if there already exists a node
by the same name.
This switch indicates to add or overwrite the node\[aq]s data fields.
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]restorefile\f[] \f[I]node\f[] \f[I]fileName\f[] \f[I]switches\f[]
Performs the inverse function of the \f[B]dumpfile\f[] operation,
restoring nodes to the tree from the file \f[I]fileName\f[].
The format of \f[I]fileName\f[] is exactly what is returned by the
\f[B]dumpfile\f[] operation.
It\[aq]s a list containing information for each node to be restored.
The information consists of 1) the relative path of the node, 2) a
sublist of key value pairs representing the node\[aq]s data, and 3) a
list of tags for the node.
Nodes are created starting from \f[I]node\f[].
Nodes can be listed in any order.
If a node\[aq]s path describes ancestor nodes that do not already exist,
they are automatically created.
The valid \f[I]switches\f[] are listed below:
.RS
.TP
.B \-overwrite
Overwrite nodes that already exist.
Normally nodes are always created, even if there already exists a node
by the same name.
This switch indicates to add or overwrite the node\[aq]s data fields.
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]root\f[] ?\f[I]node\f[]?
Returns the id of the root node.
Normally this is node 0.
If a \f[I]node\f[] argument is provided, it will become the new root of
the tree.
This lets you temporarily work within a subset of the tree.
Changing root affects operations such as \f[B]next\f[], \f[B]path\f[],
\f[B]previous\f[], etc.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]set\f[] \f[I]node\f[] \f[I]key\f[] \f[I]value\f[] ?\f[I]key\f[] \f[I]value\f[]...?
Sets one or more data fields in \f[I]node\f[].
\f[I]Node\f[] may be a tag that represents several nodes.
\f[I]Key\f[] is the name of the data field to be set and \f[I]value\f[]
is its respective value.
This operation may trigger \f[B]write\f[] and \f[B]create\f[] data
traces.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]size\f[] \f[I]node\f[]
Returns the number of nodes in the subtree.
This includes the node and all its descendants.
The size of a leaf node is 1.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]sort\f[] \f[I]node\f[] ?\f[I]switches\f[]?
\&...
.RS
.TP
.B \-ascii
Compare strings using the ASCII collation order.
.RS
.RE
.TP
.B \-command \f[I]string\f[]
Use command \f[I]string\f[] as a comparison command.
To compare two elements, evaluate a Tcl script consisting of command
with the two elements appended as additional arguments.
The script should return an integer less than, equal to, or greater than
zero if the first element is to be considered less than, equal to, or
greater than the second, respectively.
.RS
.RE
.TP
.B \-decreasing
Sort in decreasing order (largest items come first).
.RS
.RE
.TP
.B \-dictionary
Compare strings using a dictionary\-style comparison.
This is the same as \f[B]\-ascii\f[] except (a) case is ignored except
as a tie\-breaker and (b) if two strings contain embedded numbers, the
numbers compare as integers, not characters.
For example, in \f[B]\-dictionary\f[] mode, bigBoy sorts between bigbang
and bigboy, and x10y sorts between x9y and x11y.
.RS
.RE
.TP
.B \-integer
Compare the nodes as integers.
.RS
.RE
.TP
.B \-key \f[I]string\f[]
Sort based upon the node\[aq]s data field keyed by \f[I]string\f[].
Normally nodes are sorted according to their label.
.RS
.RE
.TP
.B \-path
Compare the full path of each node.
The default is to compare only its label.
.RS
.RE
.TP
.B \-real
Compare the nodes as real numbers.
.RS
.RE
.TP
.B \-recurse
Recursively sort the entire subtree rooted at \f[I]node\f[].
.RS
.RE
.TP
.B \-reorder
Recursively sort subtrees for each node.
\f[B]Warning\f[].
Unlike the normal flat sort, where a list of nodes is returned, this
will reorder the tree.
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]tag\f[] \f[I]args\f[]
Manages tags for the tree object.
See the \f[B]TAG OPERATIONS\f[] section below.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]trace\f[] \f[I]args\f[]
Manages traces for data fields in the tree object.
Traces cause Tcl commands to be executed whenever a data field of a node
is created, read, written, or unset.
Traces can be set for a specific node or a tag, representing possibly
many nodes.
See the \f[B]TRACE OPERATIONS\f[] section below.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]unset\f[] \f[I]node\f[] \f[I]key\f[]...
Removes one or more data fields from \f[I]node\f[].
\f[I]Node\f[] may be a tag that represents several nodes.
\f[I]Key\f[] is the name of the data field to be removed.
It\[aq]s not an error is \f[I]node\f[] does not contain \f[I]key\f[].
This operation may trigger \f[B]unset\f[] data traces.
.RS
.RE
.SH TAG OPERATIONS
.PP
Tags are a general means of selecting and marking nodes in the tree.
A tag is just a string of characters, and it may take any form except
that of an integer.
The same tag may be associated with many different nodes.
.PP
There are two built\-in tags: The tag \f[B]all\f[] is implicitly
associated with every node in the tree.
It may be used to invoke operations on all the nodes in the tree.
The tag \f[B]root\f[] is managed automatically by the tree object.
It specifies the node that is currently set as the root of the tree.
.PP
Most tree operations use tags.
And several operations let you operate on multiple nodes at once.
For example, you can use the \f[B]set\f[] operation with the tag
\f[B]all\f[] to set a data field in for all nodes in the tree.
.PP
Tags are invoked by the \f[B]tag\f[] operation.
The general form is \f[I]treeName\f[] \f[B]tag\f[] \f[I]operation\f[]
?\f[I]arg\f[]?...
Both \f[I]operation\f[] and its arguments determine the exact behavior
of the command.
The operations available for tags are listed below.
.TP
.B \f[I]treeName\f[] \f[B]tag add\f[] \f[I]string\f[] \f[I]node\f[]...
Adds the tag \f[I]string\f[] to one of more nodes.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]tag delete\f[] \f[I]string\f[] \f[I]node\f[]...
Deletes the tag \f[I]string\f[] from one or more nodes.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]tag forget\f[] \f[I]string\f[]
Removes the tag \f[I]string\f[] from all nodes.
It\[aq]s not an error if no nodes are tagged as \f[I]string\f[].
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]tag names\f[] ?\f[I]node\f[]?
Returns a list of tags used by the tree.
If a \f[I]node\f[] argument is present, only those tags used by
\f[I]node\f[] are returned.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]tag nodes\f[] \f[I]string\f[]
Returns a list of nodes that have the tag \f[I]string\f[].
If no node is tagged as \f[I]string\f[], then an empty string is
returned.
.RS
.RE
.SH TRACE OPERATIONS
.PP
Data fields can be traced much in the same way that you can trace Tcl
variables.
Data traces cause Tcl commands to be executed whenever a particular data
field of a node is created, read, written, or unset.
A trace can apply to one or more nodes.
You can trace a specific node by using its id, or a group of nodes by a
their tag.
.PP
The tree\[aq]s \f[B]get\f[], \f[B]set\f[], and \f[B]unset\f[] operations
can trigger various traces.
The \f[B]get\f[] operation can cause a \f[I]read\f[] trace to fire.
The \f[B]set\f[] operation causes a \f[I]write\f[] trace to fire.
And if the data field is written for the first time, you will also get a
\f[I]create\f[] trace.
The \f[B]unset\f[] operation triggers \f[I]unset\f[] traces.
.PP
Data traces are invoked by the \f[B]trace\f[] operation.
The general form is \f[I]treeName\f[] \f[B]trace\f[] \f[I]operation\f[]
?\f[I]arg\f[]?...
Both \f[I]operation\f[] and its arguments determine the exact behavior
of the command.
The operations available for traces are listed below.
.TP
.B \f[I]treeName\f[] \f[B]trace create\f[] \f[I]node\f[] \f[I]key\f[] \f[I]ops\f[] \f[I]command\f[]
Creates a trace for \f[I]node\f[] on data field \f[I]key\f[].
\f[I]Node\f[] can refer to more than one node (for example, the tag
\f[B]all\f[]).
If \f[I]node\f[] is a tag, any node with that tag can possibly trigger a
trace, invoking \f[I]command\f[].
\f[I]Command\f[] is command prefix, typically a procedure name.
Whenever a trace is triggered, four arguments are appended to
\f[I]command\f[] before it is invoked: \f[I]treeName\f[], id of the
node, \f[I]key\f[] and, \f[I]ops\f[].
Note that no nodes need have the field \f[I]key\f[].
A trace identifier in the form "trace0", "trace1", etc.
is returned.
.RS
.PP
\f[I]Ops\f[] indicates which operations are of interest, and consists of
one or more of the following letters:
.TP
.B r
Invoke \f[I]command\f[] whenever \f[I]key\f[] is read.
Both read and write traces are temporarily disabled when
\f[I]command\f[] is executed.
.RS
.RE
.TP
.B w
Invoke \f[I]command\f[] whenever \f[I]key\f[] is written.
Both read and write traces are temporarily disabled when
\f[I]command\f[] is executed.
.RS
.RE
.TP
.B c
Invoke \f[I]command\f[] whenever \f[I]key\f[] is created.
.RS
.RE
.TP
.B u
Invoke \f[I]command\f[] whenever \f[I]key\f[] is unset.
Data fields are typically unset with the \f[B]unset\f[] command.
Data fields are also unset when the tree is released, but all traces are
disabled prior to that.
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]trace delete\f[] \f[I]traceId\f[]...
Deletes one of more traces.
\f[I]TraceId\f[] is the trace identifier returned by the \f[B]trace
create\f[] operation.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]trace info\f[] \f[I]traceId\f[]
Returns information about the trace \f[I]traceId\f[].
\f[I]TraceId\f[] is a trace identifier previously returned by the
\f[B]trace create\f[] operation.
It\[aq]s the same information specified for the \f[B]trace create\f[]
operation.
It consists of the node id or tag, data field key, a string of letters
indicating the operations that are traced (it\[aq]s in the same form as
\f[I]ops\f[]) and, the command prefix.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]trace names\f[]
Returns a list of identifers for all the current traces.
.RS
.RE
.SH NOTIFY OPERATIONS
.PP
Tree objects can be shared among many clients, such as a
\f[B]hiertable\f[] widget.
Any client can create or delete nodes, sorting the tree, etc.
You can request to be notified whenever these events occur.
Notify events cause Tcl commands to be executed whenever the tree
structure is changed.
.PP
Notifications are handled by the \f[B]notify\f[] operation.
The general form is \f[I]treeName\f[] \f[B]notify\f[] \f[I]operation\f[]
?\f[I]arg\f[]?...
Both \f[I]operation\f[] and its arguments determine the exact behavior
of the command.
The operations available for events are listed below.
.TP
.B \f[I]treeName\f[] \f[B]notify create\f[] ?\f[I]switches\f[]? \f[I]command\f[] ?\f[I]args\f[]?...
Creates a notifier for the tree.
A notify identifier in the form "notify0", "notify1", etc.
is returned.
.RS
.PP
\f[I]Command\f[] and \f[I]args\f[] are saved and invoked whenever the
tree structure is changed (according to \f[I]switches\f[]).
Two arguments are appended to \f[I]command\f[] and \f[I]args\f[] before
it\[aq]s invoked: the id of the node and a string representing the type
of event that occured.
One of more switches can be set to indicate the events that are of
interest.
The valid switches are as follows:
.TP
.B \-create
Invoke \f[I]command\f[] whenever a new node has been added.
.RS
.RE
.TP
.B \-delete
Invoke \f[I]command\f[] whenever a node has been deleted.
.RS
.RE
.TP
.B \-move
Invoke \f[I]command\f[] whenever a node has been moved.
.RS
.RE
.TP
.B \-sort
Invoke \f[I]command\f[] whenever the tree has been sorted and reordered.
.RS
.RE
.TP
.B \-relabel
Invoke \f[I]command\f[] whenever a node has been relabeled.
.RS
.RE
.TP
.B \-allevents
Invoke \f[I]command\f[] whenever any of the above events occur.
.RS
.RE
.TP
.B \-whenidle
When an event occurs don\[aq]t invoke \f[I]command\f[] immediately, but
queue it to be run the next time the event loop is entered and there are
no events to process.
If subsequent events occur before the event loop is entered,
\f[I]command\f[] will still be invoked only once.
.RS
.RE
.RE
.TP
.B \f[I]treeName\f[] \f[B]notify delete\f[] \f[I]notifyId\f[]
Deletes one or more notifiers from the tree.
\f[I]NotifyId\f[] is the notifier identifier returned by the \f[B]notify
create\f[] operation.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]notify info\f[] \f[I]notifyId\f[]
Returns information about the notify event \f[I]notifyId\f[].
\f[I]NotifyId\f[] is a notify identifier previously returned by the
\f[B]notify create\f[] operation.
It\[aq]s the same information specified for the \f[B]notify\f[]
\f[B]create\f[] operation.
It consists of the notify id, a sublist of event flags (it\[aq]s in the
same form as \f[I]flags\f[]) and, the command prefix.
.RS
.RE
.TP
.B \f[I]treeName\f[] \f[B]notify names\f[]
Returns a list of identifers for all the current notifiers.
.RS
.RE
.SH C LANGUAGE API
.PP
Rbc_TreeApply, Rbc_TreeApplyBFS, Rbc_TreeApplyDFS, Rbc_TreeChangeRoot,
Rbc_TreeCreate, Rbc_TreeCreateEventHandler, Rbc_TreeCreateNode,
Rbc_TreeCreateTrace, Rbc_TreeDeleteEventHandler, Rbc_TreeDeleteNode,
Rbc_TreeDeleteTrace, Rbc_TreeExists, Rbc_TreeFindChild,
Rbc_TreeFirstChild, Rbc_TreeFirstKey, Rbc_TreeGetNode, Rbc_TreeGetToken,
Rbc_TreeGetValue, Rbc_TreeIsAncestor, Rbc_TreeIsBefore, Rbc_TreeIsLeaf,
Rbc_TreeLastChild, Rbc_TreeMoveNode, Rbc_TreeName, Rbc_TreeNextKey,
Rbc_TreeNextNode, Rbc_TreeNextSibling, Rbc_TreeNodeDegree,
Rbc_TreeNodeDepth, Rbc_TreeNodeId, Rbc_TreeNodeLabel,
Rbc_TreeNodeParent, Rbc_TreePrevNode, Rbc_TreePrevSibling,
Rbc_TreeRelabelNode, Rbc_TreeReleaseToken, Rbc_TreeRootNode,
Rbc_TreeSetValue, Rbc_TreeSize, Rbc_TreeSortNode, and
Rbc_TreeUnsetValue.
.SH KEYWORDS
.PP
tree, hiertable, widget
