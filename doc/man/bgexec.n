.\" Automatically generated by Pandoc 1.17.1
.\"
.ad l
.TH "bgexec" "n" "" "RBC(0.2)" "RBC Built-In Commands"
.hy
.SH NAME
.PP
bgexec \- Run programs in the background while handling Tk events.
.SH SYNOPSIS
.PP
\f[B]rbc::bgexec\f[] \f[I]varName\f[] ?\f[I]option\f[]
\f[I]value\f[]?...
\f[I]program\f[] ?\f[I]arg\f[]?...
.SH DESCRIPTION
.PP
The \f[B]bgexec\f[] command executes programs in the background,
allowing Tk to handle events.
A global Tcl variable \f[I]varName\f[] is set when the program has
completed.
.SH INTRODUCTION
.PP
Tcl\[aq]s \f[B]exec\f[] command is very useful for gathering information
from the operating system.
It runs a program and returns the output as its result.
This works well for Tcl\-only applications.
But for Tk applications, a problem occurs when the program takes time to
process.
Let\[aq]s say we want the get the disk usage of a directory.
We\[aq]ll use the Unix program du to get the summary.
.IP
.nf
\f[C]
set\ out\ [exec\ du\ \-s\ $dir]
puts\ "Disk\ usage\ for\ $dir\ is\ $out"
\f[]
.fi
.PP
While du is running, scrollbars won\[aq]t respond.
None of the Tk widgets will be redrawn properly.
The \f[B]send\f[] command won\[aq]t work.
And the worst part is that the application appears hung up or dead.
The problem is that while \f[B]exec\f[] is waiting for \f[I]du\f[] to
finish, Tk is not able to handle X events.
.PP
The \f[B]bgexec\f[] command performs the same functions as
\f[B]exec\f[], but also allows Tk to handle events.
You can execute a long\-running program and the Tk widgets will behave
normally.
When the program finishes, its output and the exit status are written to
Tcl variables.
This makes it easy to monitor and save the output of a program.
.SH EXAMPLE
.PP
Here is the disk usage example again, this time using \f[B]bgexec\f[].
The syntax to invoke "du" is exactly the same as the previous example,
when we used \f[B]exec\f[].
.IP
.nf
\f[C]
global\ myStatus\ myOutput
rbc::bgexec\ myStatus\ \-output\ myOutput\ du\ \-s\ $dir
puts\ "Disk\ usage\ for\ $dir\ is\ $myOutput"
\f[]
.fi
.PP
Two global variables, myStatus and myOutput, will be set by
\f[B]bgexec\f[] when du has completed.
MyStatus will contain the program\[aq]s exit status.
MyOutput, specified by the \f[B]\-output\f[] option, will store the
output of the program.
.PP
You can also terminate the program by setting the variable myStatus.
If myStatus is set before du has completed, the process is killed.
Under Unix, this is done sending by a configurable signal (by default
it\[aq]s SIGKILL).
Under Win32, this is done by calling \f[B]TerminateProcess\f[].
It makes no difference what myStatus is set to.
.IP
.nf
\f[C]
set\ myStatus\ {}
\f[]
.fi
.PP
There are several \f[B]bgexec\f[] options to collect different types of
information.
.IP
.nf
\f[C]
global\ myStatus\ myOutput\ myErrs
rbc::bgexec\ myStatus\ \-output\ myOutput\ \-error\ myErrs\ du\ \-s\ $dir
\f[]
.fi
.PP
The \f[B]\-error\f[] option is similar to \f[B]\-output\f[].
It sets a global variable when the program completes.
The variable will contain any data written to stderr by the program.
.PP
The \f[B]\-output\f[] and \f[B]\-error\f[] variables are set only after
the program completes.
But if the program takes a long time, to run you may want to receive its
partial output.
You can gather data as it becomes available using the
\f[B]\-onoutput\f[] option.
It specifies a Tcl command prefix.
Whenever new data is available, this command is executed, with the data
appended as an argument to the command.
.IP
.nf
\f[C]
proc\ GetInfo\ {\ data\ }\ {
\ \ \ \ puts\ $data
}
rbc::bgexec\ myStatus\ \-onoutput\ GetInfo\ du\ \-s\ $dir
\f[]
.fi
.PP
When output is available, the procedure GetInfo is called.
The \f[B]\-onerror\f[] option performs a similar function for the stderr
data stream.
.PP
Like \f[B]exec\f[], \f[B]bgexec\f[] returns an error if the exit code of
the program is not zero.
If you think you may get a non\-zero exit code, you might want to invoke
\f[B]bgexec\f[] from within a \f[B]catch\f[].
.IP
.nf
\f[C]
catch\ {\ rbc::bgexec\ myStatus\ \-output\ myOutput\ du\ \-s\ $dir\ }
\f[]
.fi
.PP
By default, \f[B]bgexec\f[] will wait for the program to finish.
But you can detach the program making ampersand (&) the last argument on
the command line.
.IP
.nf
\f[C]
global\ myStatus\ myOutput
rbc::bgexec\ myStatus\ \-output\ myOutput\ du\ \-s\ $dir\ &
\f[]
.fi
.PP
\f[B]Bgexec\f[] will return immediately and its result will be a list of
the spawned process ids.
If at some point you need to wait for the program to finish up, you can
use \f[B]tkwait\f[].
When the program finishes, the variable myStatus will be written to,
breaking out the \f[B]tkwait\f[] command.
.IP
.nf
\f[C]
global\ myStatus\ myOutput
rbc::bgexec\ myStatus\ \-output\ myOutput\ du\ \-s\ $dir\ &
\ \ ...
tkwait\ variable\ myStatus
\f[]
.fi
.SH SYNTAX
.PP
The \f[B]bgexec\f[] command takes the following form:
.RS
.PP
\f[B]rbc::bgexec\f[] \f[I]varName\f[] ?\f[I]option\f[]
\f[I]value\f[]?...
\f[I]program\f[] ?\f[I]arg\f[]?...
.RE
.PP
\f[I]VarName\f[] is the name of a global variable which is set when
\f[I]program\f[] has finished executing.
The exit status of will be stored in \f[I]varName\f[].
The exit status is a list of a status token, the process\-id of the
program, the exit code, and a status message.
You can also prematurely terminate the program by setting
\f[I]varName\f[].
Under Unix, the program will be sent a signal to terminate it (by
default the signal is a SIGKILL; see the \f[B]\-killsignal\f[] option).
.PP
\f[I]Program\f[] is the name of the program to be executed and
\f[I]args\f[] are any extra arguments for \f[I]program\f[].
The syntax of \f[I]program\f[] and \f[I]args\f[] is the same as the
\f[B]exec\f[] command.
So you can redirect I/O, execute pipelines, etc.
(see the \f[B]exec\f[] manual for further information) just like
\f[B]exec\f[].
If the last argument is an ampersand (&), the program will be run
detached, and \f[B]bgexec\f[] will return immediately.
\f[I]VarName\f[] will still be set with the return status when
\f[I]program\f[] completes.
.SH OPTIONS
.PP
\f[I]Option\f[] refers to the switch name always beginning with a dash
(\-).
\f[I]Value\f[] is the value of the option.
Option\-value pairs are terminated either by the program name, or double
dashes (\-\-).
The following options are available for \f[B]bgexec\f[]:
.TP
.B \-decodeerror \f[I]encodingName\f[]
Specifies the encoding of the stderr channel.
This affects only data returned to the Tcl interpreter.
No translation is done on file redirection.
.PD 0
.P
.PD
For example if data is to be converted from Unicode for use in Tcl, you
would use the "unicode" encoding.
The default is that no tranlation is performed.
.RS
.RE
.TP
.B \-decodeoutput \f[I]encodingName\f[]
Specifies the encoding of the stdout channels.
This affects only data returned to the Tcl interpreter.
No translation is done on file redirection.
.PD 0
.P
.PD
For example if data is to be converted from Unicode for use in Tcl, you
would use the "unicode" encoding.
The default is that no tranlation is performed.
.RS
.RE
.TP
.B \-error \f[I]varName\f[]
Specifies that a global variable \f[I]varName\f[] is to be set with the
contents of stderr after the program has completed.
.RS
.RE
.TP
.B \-keepnewline \f[I]boolean\f[]
Specifies that a trailing newline should be retained in the output.
If \f[I]boolean\f[] is true, the trailing newline is truncated from the
output of the \f[B]\-onoutput\f[] and \f[B]\-output\f[] variables.
The default value is true.
.RS
.RE
.TP
.B \-killsignal \f[I]signal\f[]
Specifies the signal to be sent to the program when terminating.
This is available only under Unix.
\f[I]Signal\f[] can either be a number (typically 1\-32) or a mnemonic
(such as SIGINT).
If \f[I]signal\f[] is the empty string, then no signal is sent.
The default signal is 9 (SIGKILL).
.RS
.RE
.TP
.B \-lasterror \f[I]varName\f[]
Specifies a variable \f[I]varName\f[] that is updated whenever data
becomes available from standard error of the program.
\f[I]VarName\f[] is a global variable.
Unlike the \f[B]\-error\f[] option, data is available as soon as it
arrives.
.RS
.RE
.TP
.B \-lastoutput \f[I]varName\f[]
Specifies a variable \f[I]varName\f[] that is updated whenever data
becomes available from standard output of the program.
\f[I]VarName\f[] is a global variable.
Unlike the \f[B]\-output\f[] option, data is available as soon as it
arrives.
.RS
.RE
.TP
.B \-linebuffered \f[I]boolean\f[]
Specifies that updates should be made on a line\-by\-line basis.
Normally when new data is available \f[B]bgexec\f[] will set the
variable (\f[B]\-lastoutput\f[] and \f[B]\-lasterror\f[] options) or
invoke the command (\f[B]\-onoutput\f[] and \f[B]\-onerror\f[] options)
delivering all the new data currently available.
If \f[I]boolean\f[] is true, only one line at a time will be delivered.
This can be useful when you want to process the output on a
line\-by\-line basis.
The default value is false.
.RS
.RE
.TP
.B \-output \f[I]varName\f[]
Specifies that a global variable \f[I]varName\f[] is to be set with the
output of the program, once it has completed.
If this option is not set, no output will be accumulated.
.RS
.RE
.TP
.B \-onerror \f[I]command\f[]
Specifies the start of a Tcl command that will be executed whenever new
data is available from standard error.
The data is appended to the command as an extra argument before it is
executed.
.RS
.RE
.TP
.B \-onoutput \f[I]command\f[]
Specifies the start of a Tcl command that will be executed whenever new
data is available from standard output.
The data is appended to the command as an extra argument before it is
executed.
.RS
.RE
.TP
.B \-update \f[I]varName\f[]
Deprecated.
This option is replaced by \f[B]\-lasterror\f[].
.RS
.RE
.TP
.B \-\-
This marks the end of the options.
The following argument will be considered the name of a program even if
it starts with a dash (\f[B]\-\f[]).
.RS
.RE
.SH PREEMPTION
.PP
Because \f[B]bgexec\f[] allows Tk to handle events while a program is
running, it\[aq]s possible for an application to preempt itself with
further user\- interactions.
Let\[aq]s say your application has a button that runs the disk usage
example.
And while the du program is running, the user accidently presses the
button again.
A second \f[B]bgexec\f[] program will preempt the first.
What this means is that the first program can not finish until the
second program has completed.
.PP
Care must be taken to prevent an application from preempting itself by
blocking further user\-interactions (such as button clicks).
The RBC \f[B]busy\f[] command is very useful for just these situations.
See the \f[B]busy\f[] manual for details.
.SH DIFFERENCES WITH FILEEVENT
.PP
Since Tk 4.0, a subset of \f[B]bgexec\f[] can be also achieved using the
\f[B]fileevent\f[] command.
The steps for running a program in the background are:
.PP
Execute the program with the \f[B]open\f[] command (using the "|"
syntax) and save the file handle.
.IP
.nf
\f[C]
global\ fileId
set\ fileId\ [open\ "|du\ \-s\ $dir"\ r]
\f[]
.fi
.PP
Next register a Tcl code snippet with \f[B]fileevent\f[] to be run
whenever output is available on the file handle.
The code snippet will read from the file handle and save the output in a
variable.
.IP
.nf
\f[C]
fileevent\ fileId\ readable\ {
\ \ \ \ if\ {\ [gets\ $fileId\ line]\ <\ 0\ }\ {
\ \ close\ $fileId
\ \ set\ output\ $temp
\ \ unset\ fileId\ temp
\ \ \ \ }\ else\ {
\ \ append\ temp\ $line
\ \ \ \ }
}
\f[]
.fi
.PP
The biggest advantage of \f[B]bgexec\f[] is that, unlike
\f[B]fileevent\f[], it requires no additional Tcl code to run a program.
It\[aq]s simpler and less error prone.
You don\[aq]t have to worry about non\-blocking I/O.
It\[aq]s handled tranparently for you.
.PP
\f[B]Bgexec\f[] runs programs that \f[B]fileevent\f[] can not.
\f[B]Fileevent\f[] assumes that the when stdout is closed the program
has completed.
But some programs, like the Unix compress program, reopen stdout,
fooling \f[B]fileevent\f[] into thinking the program has terminated.
In the example above, we assume that the program will write and flush
its output line\- by\-line.
However running another program, your application may block in the
\f[B]gets\f[] command reading a partial line.
.PP
\f[B]Bgexec\f[] lets you get back the exit status of the program.
It also allows you to collect data from both stdout and stderr
simultaneously.
Finally, since data collection is handled in C code, \f[B]bgexec\f[] is
faster.
You get back to the Tk event loop more quickly, making your application
seem more responsive.
.SH SEE ALSO
.PP
busy, exec, tkwait
.SH KEYWORDS
.PP
exec, background, busy
