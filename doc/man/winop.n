.\" Automatically generated by Pandoc 1.17.1
.\"
.ad l
.TH "winop" "n" "" "RBC(0.2)" "RBC Built-In Commands"
.hy
.SH NAME
.PP
winop \- Perform assorted window operations
.SH SYNOPSIS
.PP
\f[B]winop changes\f[] ?\f[I]window\f[]?...
.PP
\f[B]winop colormap\f[] ?\f[I]window\f[]?...
.PP
\f[B]winop convolve\f[] ?\f[I]srcPhoto\f[] \f[I]destPhoto\f[]
\f[I]filter\f[]?...
.PP
\f[B]winop image\f[] ?\f[I]args\f[]?...
.PP
\f[B]winop lower\f[] ?\f[I]window\f[]?...
.PP
\f[B]winop map\f[] ?\f[I]window\f[]?...
.PP
\f[B]winop move\f[] \f[I]window\f[] \f[I]x\f[] \f[I]y\f[]
.PP
\f[B]winop quantize\f[] \f[I]srcPhoto\f[] \f[I]destPhoto\f[]
\f[I]?nColors?\f[]
.PP
\f[B]winop query\f[]
.PP
\f[B]winop raise\f[] ?\f[I]window\f[]?...
.PP
\f[B]winop readjpeg\f[] ?\f[I]fileName\f[] \f[I]photoName\f[]?...
.PP
\f[B]winop subsample\f[] ?\f[I]srcPhoto\f[] \f[I]destPhoto\f[]
\f[I]?horzFilter\f[] \f[I]vertFilter?\f[]...
.PP
\f[B]winop snap\f[] \f[I]window\f[] \f[I]photoName\f[] \f[I]?width\f[]
\f[I]height?\f[]
.PP
\f[B]winop subsample\f[] \f[I]srcPhoto\f[] \f[I]destPhoto\f[] \f[I]x\f[]
\f[I]y\f[] \f[I]width\f[] \f[I]height\f[] \f[I]?horzFilter?\f[]
\f[I]?vertFilter?\f[]
.PP
\f[B]winop unmap\f[] ?\f[I]window\f[]?...
.PP
\f[B]winop warpto\f[] ?\f[I]window\f[]?
.SH DESCRIPTION
.PP
The \f[B]winop\f[] command performs various window operations on Tk
windows using low\-level Xlib function calls to work around window
manager pecularities.
.SH INTRODUCTION
.PP
Tk has several commands for manipulating its windows: \f[B]raise\f[],
\f[B]lower\f[], \f[B]wm\f[], etc.
These commands ask the window manager to perform operations on Tk
windows.
In some cases, a particular window manager won\[aq]t perform the
operation as expected.
.PP
For example, if you positioned a toplevel window using \f[B]wm
geometry\f[], the window may not actually be at those particular
coordinates.
The position of the window may be offset by dimensions of the title bar
added by the window manager.
.PP
In situations like these, the \f[B]winop\f[] command can be used to
workaround these difficulties.
Instead, it makes low\-level Xlib (such \f[B]XRaiseWindow\f[] and
\f[B]XMapWindow\f[]) calls to perform these operations.
.IP
.nf
\f[C]
toplevel\ .top
wm\ withdraw\ .top

#\ Set\ the\ geometry\ to\ make\ the\ window\ manager
#\ place\ the\ window.
wm\ geometry\ .top\ +100+100

#\ Move\ the\ window\ to\ the\ desired\ location
#\ and\ "update"\ to\ force\ the\ window\ manager
#\ to\ recognize\ it.
winop\ move\ .top\ 100\ 100
update

wm\ deiconify\ .top
winop\ move\ .top\ 100\ 100
\f[]
.fi
.SH OPERATIONS
.PP
The following operations are available for the \f[B]winop\f[] command:
.TP
.B \f[B]winop lower\f[] ?\f[I]window\f[]?...
Lowers \f[I]window\f[] to the bottom of the X window stack.
\f[I]Window\f[] is the path name of a Tk window.
.RS
.RE
.TP
.B \f[B]winop map\f[] ?\f[I]window\f[]?...
Maps \f[I]window\f[] on the screen.
\f[I]Window\f[] is the path name of a Tk window.
If \f[I]window\f[] is already mapped, this command has no effect.
.RS
.RE
.TP
.B \f[B]winop move\f[] \f[I]window\f[] \f[I]x\f[] \f[I]y\f[]
Move \f[I]window\f[] to the screen location specified by \f[I]x\f[] and
\f[I]y\f[].
\f[I]Window\f[] is the path name of a Tk window, while \f[I]x\f[] and
\f[I]y\f[] are screen coordinates.
This command returns the empty string.
.RS
.RE
.TP
.B \f[B]winop raise\f[] ?\f[I]window\f[]?...
Raises \f[I]window\f[] to the top of the X window stack.
\f[I]Window\f[] must be a valid path name of a Tk window.
This command returns the empty string.
.RS
.RE
.TP
.B \f[B]winop snap\f[] \f[I]window\f[] \f[I]photoName\f[]
Takes a snapshot of the \f[I]window\f[] and stores the contents in the
photo image \f[I]photoName\f[].
\f[I]Window\f[] is the valid path name of a Tk window which must be
totally visible (unobscured).
\f[I]PhotoName\f[] is the name of a Tk photo image which must already
exist.
This command can fail if the window is obscured in any fashion, such as
covered by another window or partially offscreen.
In that case, an error message is returned.
.RS
.RE
.TP
.B \f[B]winop unmap\f[] ?\f[I]window\f[]?...
Unmaps \f[I]window\f[] from the screen.
\f[I]Window\f[] is the path name of a Tk window.
.RS
.RE
.TP
.B \f[B]winop warpto\f[] ?\f[I]window\f[]?
Warps the pointer to \f[I]window\f[].
\f[I]Window\f[] is the path name of a Tk window which must be mapped.
If \f[I]window\f[] is in the form \f[I]\@x,y\f[], where \f[I]x\f[] and
\f[I]y\f[] are root screen coordinates, the pointer is warped to that
location on the screen.
.RS
.PP
[\f[I]I\[aq]ve\f[] \f[I]never\f[] \f[I]heard\f[] \f[I]a\f[]
\f[I]good\f[] \f[I]case\f[] \f[I]for\f[] \f[I]warping\f[] \f[I]the\f[]
\f[I]pointer\f[] \f[I]in\f[] \f[I]an\f[] \f[I]application.\f[]
\f[I]It\f[] \f[I]can\f[] \f[I]be\f[] \f[I]useful\f[] \f[I]for\f[]
\f[I]testing,\f[] \f[I]but\f[] \f[I]in\f[] \f[I]applications,\f[]
\f[I]it\[aq]s\f[] \f[I]always\f[] \f[I]a\f[] \f[I]bad\f[] \f[I]idea.\f[]
\f[I]Simply\f[] \f[I]stated,\f[] \f[I]the\f[] \f[I]user\f[]
\f[I]owns\f[] \f[I]the\f[] \f[I]pointer,\f[] \f[I]not\f[] \f[I]the\f[]
\f[I]application.\f[] \f[I]If\f[] \f[I]you\f[] \f[I]have\f[] \f[I]an\f[]
\f[I]application\f[] \f[I]that\f[] \f[I]needs\f[] \f[I]it,\f[]
\f[I]I\[aq]d\f[] \f[I]like\f[] \f[I]to\f[] \f[I]hear\f[] \f[I]about\f[]
\f[I]it.\f[]]
.PP
If no \f[I]window\f[] argument is present the current location of the
pointer is returned.
The location is returned as a list in the form "\f[I]x\f[] \f[I]y\f[]",
where \f[I]x\f[] and \f[I]y\f[] are the current coordinates of the
pointer.
.RE
.SH KEYWORDS
.PP
window, map, raise, lower, pointer, warp
